***********************************************************************
*
*	CODE GENERATION LISTING FOR: 0.2
*	COMPILER VERSION: 6.0.0.52
*
***********************************************************************

**************************************************
	List function block: TON
**************************************************

FUNCTION_BLOCK TON

	{ DE:"<HTML>The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.</br></br>
<img src= tonscheme.png>
<ul>
<li>if IN is FALSE Q is false</li>
<li>Q becomes TRUE as IN remains TRUE for PT milliseconds</li>
<li>Q remains TRUE until IN remains TRUE</li>
</ul>" }

        VAR_INPUT
IN : BOOL;	{ DE:"Timer input source" }
PT : UDINT;	{ DE:"Preset time value (ms)" }
	END_VAR

        VAR_OUTPUT
Q : BOOL;	{ DE:"Timer output" }
ET : UDINT;	{ DE:"Timer current value (ms)" }
	END_VAR

        VAR_EXTERNAL
	{G:"System_Timers"}
sysTimer AT %MD0.0 : UDINT;	{ DE:"System timer [ms]" }
	END_VAR

        VAR
timStart : UDINT;	{ DE:"Time value at start of counting" }
	END_VAR

END_FUNCTION_BLOCK

06A642F0  55                            push ebp
06A642F1  8B EB                         mov ebp, ebx
06A642F3  57                            push edi

#0		{SRC:TON}
#1		
#2			(*	Check if in counting	*)
#3		
#4			LD		IN
(*) UNDEF
06A642F4  33 C0                         xor eax, eax
06A642F6  8A 45 04                      mov al, 4[ebp]

#5			JMPCN	lReset
(-) BOOL
06A642F9  84 C0                         test al, al
06A642FB  90 74 61 90 90 90             je 06A6435FH

#6		
#7			(*	Check if Q is TRUE *)
#8			LD		Q
(*) UNDEF
06A64301  33 C0                         xor eax, eax
06A64303  8A 45 09                      mov al, 9[ebp]

#9			RETC
#10			
(-) BOOL
06A64306  84 C0                         test al, al
06A64308  90 75 6A 90 90 90             jne 06A64375H

#11			(*	Check if already in counting *)
#12			LD		timStart
(*) UNDEF
06A6430E  8B 45 00                      mov eax, [ebp]

#13			EQ		0
(*) UDINT
06A64311  3D 00 00 00 00                cmp eax, 0
06A64316  0F 94 C0                      sete al
06A64319  25 FF 00 00 00                and eax, 0FFh

#14			JMPCN	lUpdate
(-) BOOL
06A6431E  84 C0                         test al, al
06A64320  90 74 0C 90 90 90             je 06A6432FH

#15		
#16			(*	Start of counting *)
#17			LD		sysTimer
(*) UNDEF
06A64326  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#18			ST		timStart
(*) UDINT
06A6432C  89 45 00                      mov [ebp], eax

#19			
#20		lUpdate:
#21		
#22			(*	Update timer and check if time elapsed *)
#23			LD		sysTimer
(*) UNDEF
06A6432F  8B 05 CC CC CC CC             mov eax, [CCCCCCCCH] ; %M0+0

#24			SUB		timStart
(*) UDINT
06A64335  2B 45 00                      sub eax, [ebp]

#25			ST		ET
(*) UDINT
06A64338  89 45 0A                      mov 10[ebp], eax

#26			GE		PT
(*) UDINT
06A6433B  3B 45 05                      cmp eax, [ebp+5]
06A6433E  0F 93 C0                      setae al
06A64341  25 FF 00 00 00                and eax, 0FFh

#27			ST		Q
(*) BOOL
06A64346  84 C0                         test al, al
06A64348  0F 95 45 09                   setne 9[ebp]

#28			RETCN
#29		
(-) BOOL
06A6434C  84 C0                         test al, al
06A6434E  90 74 24 90 90 90             je 06A64375H

#30			(*	Limit actual time value *)
#31			LD		PT
(*) UNDEF
06A64354  8B 45 05                      mov eax, 5[ebp]

#32			ST		ET
(*) UDINT
06A64357  89 45 0A                      mov 10[ebp], eax

#33			RET
#34		
(-) UDINT
06A6435A  EB 19 90 90 90                jmp 06A64375H

#35		lReset:
#36		
#37			(*	Reset status *)
#38			LD		0
(*) UNDEF
06A6435F  B8 00 00 00 00                mov eax, 00H

#39			ST		ET
(*) USINT
06A64364  89 45 0A                      mov 10[ebp], eax

#40			ST		timStart
(*) UDINT
06A64367  89 45 00                      mov [ebp], eax

#41			LD		FALSE
(*) UNDEF
06A6436A  B8 00 00 00 00                mov eax, 00H

#42			ST		Q
(*) BOOL
06A6436F  84 C0                         test al, al
06A64371  0F 95 45 09                   setne 9[ebp]

06A64375  5F                            pop edi
06A64376  5D                            pop ebp

06A64377  C3                            ret


Frame allocation (hex):

	0000       : VAR timStart
	0004 bit  0: VAR IN
	0005       : VAR PT
	0009 bit  0: VAR Q
	000A       : VAR ET

END_FUNCTION_BLOCK
**************************************************
	List program: main
**************************************************

PROGRAM main

END_PROGRAM

06A64380  55                            push ebp
06A64381  8B EC                         mov ebp, esp
06A64383  60                            pushad

#0		{SRC:main}
#1		(*$WAITSWITCH$*)
#2		
#3			(* cnt := cnt + 1; *)
#4			LD		cnt	{LNXT:2|2|-1}
(*) UNDEF
06A64384  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+250

#5			ADD		1	{LNXT:2|2|-1}
(*) INT
06A6438B  05 01 00 00 00                add eax, 1

#6			ST		cnt	{LNXT:2|2|-1}
(*) INT
06A64390  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+250

06A64397  61                            popad
06A64398  5D                            pop ebp

06A64399  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
06A6439A  55                            push ebp
06A6439B  8B EC                         mov ebp, esp

06A6439D  8B E5                         mov esp, ebp
06A6439F  5D                            pop ebp

06A643A0  C3                            ret


*** OUTPUT:
06A643A1  55                            push ebp
06A643A2  8B EC                         mov ebp, esp

06A643A4  8B E5                         mov esp, ebp
06A643A6  5D                            pop ebp

06A643A7  C3                            ret



**************************************************
	Task Background init code
**************************************************

06A643A8  55                            push ebp
06A643A9  8B EC                         mov ebp, esp

06A643AB  8B E5                         mov esp, ebp
06A643AD  5D                            pop ebp

06A643AE  C3                            ret

**************************************************
	List program: InitParDB
**************************************************

PROGRAM InitParDB

        VAR
warningsKiller : USINT;
dummyCrc32 : UDINT;
	END_VAR

END_PROGRAM

06A643C0  55                            push ebp
06A643C1  8B EC                         mov ebp, esp
06A643C3  60                            pushad

#0		{SRC:InitParDB}
#1		(*$WAITSWITCH$*)
#2		
#3			(* dummyCrc32 := 2941189107; *)
#4			MOVE		2941189107,dummyCrc32	{LNXT:3|5|-1}
(*) UDINT
06A643C4  B8 F3 FB 4E AF                mov eax, AF4EFBF3H
06A643C9  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+12

#5		
#6			(* warningsKiller := sysDBase_SetExtTable( ADR( $$ParDB ), $$ParDBLength ); *)
#7			ADR		$$ParDB	{LNXT:5|3|-1}
(*) UDINT
06A643CF  B8 CC CC CC CC                mov eax, CCCCCCCCH ; $$CODE$$+240

#8			sysDBase_SetExtTable		$$ParDBLength	{LNXT:5|3|-1}
(*) @USINT
06A643D4  68 0D 00 00 00                push 13
06A643D9  8B C8                         mov ecx, eax
06A643DB  51                            push ecx
06A643DC  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; sysDBase_SetExtTable
06A643E1  FF D1                         call ecx
06A643E3  81 C4 08 00 00 00             add esp, 8

#9			ST		warningsKiller	{LNXT:5|3|-1}
(*) USINT
06A643E9  88 05 CC CC CC CC             mov [CCCCCCCCH], al ; $$DATA$$+16

06A643EF  61                            popad
06A643F0  5D                            pop ebp

06A643F1  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
06A643F2  C3                            ret


*** OUTPUT:
06A643F3  C3                            ret



**************************************************
	Task Serv init code
**************************************************

06A643F4  55                            push ebp
06A643F5  8B EC                         mov ebp, esp

06A643F7  8B E5                         mov esp, ebp
06A643F9  5D                            pop ebp

06A643FA  C3                            ret

**************************************************
	List program: LVL
**************************************************

PROGRAM LVL

        VAR
Fault_A : BOOL := FALSE;
Fault_B : BOOL := FALSE;
Fault_C : BOOL := FALSE;
RotationMode : BOOL := FALSE;	{ DE:"Локальна змінна ротація 0-вимкнена" }
Rotationnumber : INT := 1;	{ DE:"Номер в ротації" }
FastRunMode : BOOL := FALSE;	{ DE:"Локальна змінна Прогонка 0-вимкнена" }
PriorityMotor : INT := 1;	{ DE:"Priority 0 = Motor_A, 1 = Motor_B, 2 = Motor_C" }
RunTime_START : TIME;	{ DE:"Час роботи двигуна A" }
TM_WAIT : INT;	{ DE:"Час затримки перевірки запуску двигуна" }
ErrorTimer_A : TON;
ErrorTimer_B : TON;
ErrorTimer_C : TON;
CurrentMotor : INT := 1;
ErrorCode : INT := 0;
Max_Level_3 : INT := 150;	{ DE:"Рівень запуску 1 насоса" }
Max_Level_2 : INT := 120;	{ DE:"Рівень запуску 1 насоса" }
Max_Level_1 : INT := 80;	{ DE:"Рівень запуску 1 насоса" }
Min_Level : INT := 30;	{ DE:"Рівень зупинки насоса" }
PumpIntervalTimer_1 : TON;	{ DE:"інтервал для запуску прогонки" }
PumpRunTimer_1 : TON;	{ DE:"Час прогонки" }
TestRunActive_1 : BOOL := FALSE;	{ DE:"Тригер готовності прогонки" }
TestRunRunning_1 : BOOL := FALSE;	{ DE:"Прогонка виконується" }
PumpIntervalTimer_2 : TON;	{ DE:"інтервал для запуску прогонки" }
PumpRunTimer_2 : TON;	{ DE:"Час прогонки" }
TestRunActive_2 : BOOL := FALSE;	{ DE:"Тригер готовності прогонки" }
TestRunRunning_2 : BOOL := FALSE;	{ DE:"Прогонка виконується" }
PumpIntervalTimer_3 : TON;	{ DE:"інтервал для запуску прогонки" }
PumpRunTimer_3 : TON;	{ DE:"Час прогонки" }
TestRunActive_3 : BOOL := FALSE;	{ DE:"Тригер готовності прогонки" }
TestRunRunning_3 : BOOL := FALSE;	{ DE:"Прогонка виконується" }
CurrentPump : INT := 1;
	END_VAR

END_PROGRAM

06A64410  55                            push ebp
06A64411  8B EC                         mov ebp, esp
06A64413  60                            pushad

#0		{SRC:LVL}
#1		(*$WAITSWITCH$*)
#2		
#3			(* TM_WAIT:=3000; *)
#4			MOVE		3000,TM_WAIT	{LNXT:4|9|-1}
(*) UDINT
06A64414  B8 B8 0B 00 00                mov eax, 0BB8H
06A64419  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+18

#5		
#6		
#7			(* IF Rotation <> RotationMode *)
#8			LD		Rotation	{LNXT:9|-1|-1}
(*) UNDEF
06A64420  33 C0                         xor eax, eax
06A64422  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %M110+16

#9			NE		RotationMode	{LNXT:9|-1|-1}
(*) BOOL
06A64428  33 C9                         xor ecx, ecx
06A6442A  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+17
06A64430  33 C1                         xor eax, ecx

#10			JMPCN	$label0	{LNXT:9|10|16}
(-) BOOL
06A64432  84 C0                         test al, al
06A64434  90 74 14 90 90 90             je 06A6444BH

#11		
#12			(* THEN *)
#13		
#14				(* RotationMode := Rotation; *)
#15				MOVE		Rotation,RotationMode	{LNXT:10|16|-1}
(*) BOOL
06A6443A  33 C0                         xor eax, eax
06A6443C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %M110+16
06A64442  84 C0                         test al, al
06A64444  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+17

#16		
#17		$label0:
#18			(* END_IF *)
#19		
#20		
#21			(* IF RotationMode = FALSE *)
#22			LD		RotationMode	{LNXT:16|-1|-1}
(*) UNDEF
06A6444B  33 C0                         xor eax, eax
06A6444D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+17

#23			EQ		FALSE	{LNXT:16|-1|-1}
(*) BOOL
06A64453  35 01 00 00 00                xor eax, 00000001H

#24			JMPCN	$label1	{LNXT:16|17|24}
(-) BOOL
06A64458  84 C0                         test al, al
06A6445A  90 74 11 90 90 90             je 06A6446EH

#25		
#26			(* THEN *)
#27		
#28				(* PriorityMotor := Priority; *)
#29				MOVE		Priority,PriorityMotor	{LNXT:17|24|-1}
(*) BOOL
06A64460  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; %M110+12
06A64467  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+20

#30		
#31		$label1:
#32			(* END_IF *)
#33		
#34		
#35			(* IF FastRun <> FastRunMode *)
#36			LD		FastRun	{LNXT:24|-1|-1}
(*) UNDEF
06A6446E  33 C0                         xor eax, eax
06A64470  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %M110+18

#37			NE		FastRunMode	{LNXT:24|-1|-1}
(*) BOOL
06A64476  33 C9                         xor ecx, ecx
06A64478  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+22
06A6447E  33 C1                         xor eax, ecx

#38			JMPCN	$label2	{LNXT:24|25|32}
(-) BOOL
06A64480  84 C0                         test al, al
06A64482  90 74 14 90 90 90             je 06A64499H

#39		
#40			(* THEN *)
#41		
#42				(* FastRunMode := FastRun; *)
#43				MOVE		FastRun,FastRunMode	{LNXT:25|32|-1}
(*) BOOL
06A64488  33 C0                         xor eax, eax
06A6448A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %M110+18
06A64490  84 C0                         test al, al
06A64492  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+22

#44		
#45		$label2:
#46			(* END_IF *)
#47		
#48		
#49			(* IF Tank_Level >= Max_Level_1 and RotationMode *)
#50			LD		Tank_Level	{LNXT:32|-1|-1}
(*) UNDEF
06A64499  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#51			GE		Max_Level_1	{LNXT:32|-1|-1}
(*) INT
06A644A0  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A644A7  3B C1                         cmp eax, ecx
06A644A9  0F 9D C0                      setge al
06A644AC  25 FF 00 00 00                and eax, 0FFh

#52			AND		RotationMode	{LNXT:32|-1|-1}
(*) BOOL
06A644B1  33 C9                         xor ecx, ecx
06A644B3  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+17
06A644B9  23 C1                         and eax, ecx

#53			JMPCN	$label3	{LNXT:32|35|70}
(-) BOOL
06A644BB  84 C0                         test al, al
06A644BD  0F 84 3A 02 00 00             je 06A646FDH

#54		
#55			(* THEN *)
#56		
#57		
#58				(* CASE Rotationnumber OF *)
#59		
#60				(* 0: *)
#61				LD		Rotationnumber	{LNXT:35|-1|-1}
(*) UNDEF
06A644C3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+28

#62				EQ		0	{LNXT:35|-1|-1}
(*) INT
06A644CA  3D 00 00 00 00                cmp eax, 0
06A644CF  0F 94 C0                      sete al
06A644D2  25 FF 00 00 00                and eax, 0FFh

#63				JMPC		$label5	{LNXT:35|36|40}
(-) BOOL
06A644D7  84 C0                         test al, al
06A644D9  90 75 40 90 90 90             jne 06A6451CH

#64		
#65				(* 1: *)
#66				LD		Rotationnumber	{LNXT:40|-1|-1}
(*) UNDEF
06A644DF  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+28

#67				EQ		1	{LNXT:40|-1|-1}
(*) INT
06A644E6  3D 01 00 00 00                cmp eax, 1
06A644EB  0F 94 C0                      sete al
06A644EE  25 FF 00 00 00                and eax, 0FFh

#68				JMPC		$label6	{LNXT:40|41|45}
(-) BOOL
06A644F3  84 C0                         test al, al
06A644F5  0F 85 96 00 00 00             jne 06A64591H

#69		
#70				(* 2: *)
#71				LD		Rotationnumber	{LNXT:45|-1|-1}
(*) UNDEF
06A644FB  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+28

#72				EQ		2	{LNXT:45|-1|-1}
(*) INT
06A64502  3D 02 00 00 00                cmp eax, 2
06A64507  0F 94 C0                      sete al
06A6450A  25 FF 00 00 00                and eax, 0FFh

#73				JMPC		$label7	{LNXT:45|46|53}
(-) BOOL
06A6450F  84 C0                         test al, al
06A64511  0F 85 EF 00 00 00             jne 06A64606H

#74				JMP		$label4	{LNXT:45|46|53}
(-) BOOL
06A64517  E9 5A 01 00 00                jmp 06A64676H

#75		
#76				(* Istruzioni di ciascun CASE: *)
#77		
#78		$label5:
#79		
#80					(* IF Fault_A AND Avto_A AND NOT Motor_B AND NOT Motor_C *)
#81					LD		Motor_C	{LNXT:36|-1|-1}
(*) UNDEF
06A6451C  33 C0                         xor eax, eax
06A6451E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#82					NOT	{LNXT:36|-1|-1}
(*) BOOL
06A64524  84 C0                         test al, al
06A64526  0F 94 C0                      sete al

#83					AND(		Motor_B	{LNXT:36|-1|-1}
(*) BOOL
06A64529  50                            push eax
06A6452A  33 C0                         xor eax, eax
06A6452C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#84					NOT	{LNXT:36|-1|-1}
(*) BOOL
06A64532  84 C0                         test al, al
06A64534  0F 94 C0                      sete al

#85					AND(		Fault_A	{LNXT:36|-1|-1}
(*) BOOL
06A64537  50                            push eax
06A64538  33 C0                         xor eax, eax
06A6453A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+23

#86					NOT	{LNXT:36|-1|-1}
(*) BOOL
06A64540  84 C0                         test al, al
06A64542  0F 94 C0                      sete al

#87					AND		Avto_A	{LNXT:36|-1|-1}
(*) BOOL
06A64545  33 C9                         xor ecx, ecx
06A64547  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+30
06A6454D  23 C1                         and eax, ecx

#88					)	{LNXT:36|-1|-1}
(*) BOOL
06A6454F  8B C8                         mov ecx, eax
06A64551  58                            pop eax
06A64552  23 C1                         and eax, ecx

#89					)	{LNXT:36|-1|-1}
(*) BOOL
06A64554  8B C8                         mov ecx, eax
06A64556  58                            pop eax
06A64557  23 C1                         and eax, ecx

#90					JMPCN	$label8	{LNXT:36|37|53}
(-) BOOL
06A64559  84 C0                         test al, al
06A6455B  90 74 2E 90 90 90             je 06A6458CH

#91		
#92					(* THEN *)
#93		
#94						(* Motor_A := TRUE; *)
#95						MOVE		TRUE,Motor_A	{LNXT:37|38|-1}
(*) BOOL
06A64561  B8 01 00 00 00                mov eax, 01H
06A64566  84 C0                         test al, al
06A64568  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#96		
#97						(* Rotationnumber := (Rotationnumber + 1) MOD 3; *)
#98						LD		Rotationnumber	{LNXT:38|53|-1}
(*) UNDEF
06A6456F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+28

#99						ADD		1	{LNXT:38|53|-1}
(*) INT
06A64576  05 01 00 00 00                add eax, 1

#100						MOD		3	{LNXT:38|53|-1}
(*) INT
06A6457B  99                            cdq
06A6457C  B9 03 00 00 00                mov ecx, 3
06A64581  F7 F9                         idiv ecx
06A64583  8B C2                         mov eax, edx

#101						ST		Rotationnumber	{LNXT:38|53|-1}
(*) INT
06A64585  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+28

#102		
#103		$label8:
#104					(* END_IF *)
#105					JMP		$label4	{LNXT:1|53|-1}
(-) INT
06A6458C  E9 E5 00 00 00                jmp 06A64676H

#106		
#107		$label6:
#108		
#109					(* IF Fault_B AND Avto_B AND NOT Motor_A AND NOT Motor_C *)
#110					LD		Motor_C	{LNXT:41|-1|-1}
(*) UNDEF
06A64591  33 C0                         xor eax, eax
06A64593  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#111					NOT	{LNXT:41|-1|-1}
(*) BOOL
06A64599  84 C0                         test al, al
06A6459B  0F 94 C0                      sete al

#112					AND(		Motor_A	{LNXT:41|-1|-1}
(*) BOOL
06A6459E  50                            push eax
06A6459F  33 C0                         xor eax, eax
06A645A1  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#113					NOT	{LNXT:41|-1|-1}
(*) BOOL
06A645A7  84 C0                         test al, al
06A645A9  0F 94 C0                      sete al

#114					AND(		Fault_B	{LNXT:41|-1|-1}
(*) BOOL
06A645AC  50                            push eax
06A645AD  33 C0                         xor eax, eax
06A645AF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31

#115					NOT	{LNXT:41|-1|-1}
(*) BOOL
06A645B5  84 C0                         test al, al
06A645B7  0F 94 C0                      sete al

#116					AND		Avto_B	{LNXT:41|-1|-1}
(*) BOOL
06A645BA  33 C9                         xor ecx, ecx
06A645BC  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+32
06A645C2  23 C1                         and eax, ecx

#117					)	{LNXT:41|-1|-1}
(*) BOOL
06A645C4  8B C8                         mov ecx, eax
06A645C6  58                            pop eax
06A645C7  23 C1                         and eax, ecx

#118					)	{LNXT:41|-1|-1}
(*) BOOL
06A645C9  8B C8                         mov ecx, eax
06A645CB  58                            pop eax
06A645CC  23 C1                         and eax, ecx

#119					JMPCN	$label9	{LNXT:41|42|53}
(-) BOOL
06A645CE  84 C0                         test al, al
06A645D0  90 74 2E 90 90 90             je 06A64601H

#120		
#121					(* THEN *)
#122		
#123						(* Motor_B := TRUE; *)
#124						MOVE		TRUE,Motor_B	{LNXT:42|43|-1}
(*) BOOL
06A645D6  B8 01 00 00 00                mov eax, 01H
06A645DB  84 C0                         test al, al
06A645DD  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#125		
#126						(* Rotationnumber := (Rotationnumber + 1) MOD 3; *)
#127						LD		Rotationnumber	{LNXT:43|53|-1}
(*) UNDEF
06A645E4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+28

#128						ADD		1	{LNXT:43|53|-1}
(*) INT
06A645EB  05 01 00 00 00                add eax, 1

#129						MOD		3	{LNXT:43|53|-1}
(*) INT
06A645F0  99                            cdq
06A645F1  B9 03 00 00 00                mov ecx, 3
06A645F6  F7 F9                         idiv ecx
06A645F8  8B C2                         mov eax, edx

#130						ST		Rotationnumber	{LNXT:43|53|-1}
(*) INT
06A645FA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+28

#131		
#132		$label9:
#133					(* END_IF *)
#134					JMP		$label4	{LNXT:1|53|-1}
(-) INT
06A64601  EB 73 90 90 90                jmp 06A64676H

#135		
#136		$label7:
#137		
#138					(* IF Fault_C AND Avto_C AND NOT Motor_A AND NOT Motor_B *)
#139					LD		Motor_B	{LNXT:46|-1|-1}
(*) UNDEF
06A64606  33 C0                         xor eax, eax
06A64608  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#140					NOT	{LNXT:46|-1|-1}
(*) BOOL
06A6460E  84 C0                         test al, al
06A64610  0F 94 C0                      sete al

#141					AND(		Motor_A	{LNXT:46|-1|-1}
(*) BOOL
06A64613  50                            push eax
06A64614  33 C0                         xor eax, eax
06A64616  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#142					NOT	{LNXT:46|-1|-1}
(*) BOOL
06A6461C  84 C0                         test al, al
06A6461E  0F 94 C0                      sete al

#143					AND(		Fault_C	{LNXT:46|-1|-1}
(*) BOOL
06A64621  50                            push eax
06A64622  33 C0                         xor eax, eax
06A64624  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33

#144					NOT	{LNXT:46|-1|-1}
(*) BOOL
06A6462A  84 C0                         test al, al
06A6462C  0F 94 C0                      sete al

#145					AND		Avto_C	{LNXT:46|-1|-1}
(*) BOOL
06A6462F  33 C9                         xor ecx, ecx
06A64631  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+34
06A64637  23 C1                         and eax, ecx

#146					)	{LNXT:46|-1|-1}
(*) BOOL
06A64639  8B C8                         mov ecx, eax
06A6463B  58                            pop eax
06A6463C  23 C1                         and eax, ecx

#147					)	{LNXT:46|-1|-1}
(*) BOOL
06A6463E  8B C8                         mov ecx, eax
06A64640  58                            pop eax
06A64641  23 C1                         and eax, ecx

#148					JMPCN	$label10	{LNXT:46|47|53}
(-) BOOL
06A64643  84 C0                         test al, al
06A64645  90 74 2E 90 90 90             je 06A64676H

#149		
#150					(* THEN *)
#151		
#152						(* Motor_C := TRUE; *)
#153						MOVE		TRUE,Motor_C	{LNXT:47|48|-1}
(*) BOOL
06A6464B  B8 01 00 00 00                mov eax, 01H
06A64650  84 C0                         test al, al
06A64652  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#154		
#155						(* Rotationnumber := (Rotationnumber + 1) MOD 3; *)
#156						LD		Rotationnumber	{LNXT:48|53|-1}
(*) UNDEF
06A64659  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+28

#157						ADD		1	{LNXT:48|53|-1}
(*) INT
06A64660  05 01 00 00 00                add eax, 1

#158						MOD		3	{LNXT:48|53|-1}
(*) INT
06A64665  99                            cdq
06A64666  B9 03 00 00 00                mov ecx, 3
06A6466B  F7 F9                         idiv ecx
06A6466D  8B C2                         mov eax, edx

#159						ST		Rotationnumber	{LNXT:48|53|-1}
(*) INT
06A6466F  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+28

#160		
#161		$label10:
#162					(* END_IF *)
#163		
#164		$label4:
#165		
#166				(* END_CASE *)
#167		
#168		
#169				(* IF Fault_A or NOT Avto_A *)
#170				LD		Avto_A	{LNXT:53|-1|-1}
(*) UNDEF
06A64676  33 C0                         xor eax, eax
06A64678  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30

#171				NOT	{LNXT:53|-1|-1}
(*) BOOL
06A6467E  84 C0                         test al, al
06A64680  0F 94 C0                      sete al

#172				OR		Fault_A	{LNXT:53|-1|-1}
(*) BOOL
06A64683  33 C9                         xor ecx, ecx
06A64685  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+23
06A6468B  0B C1                         or eax, ecx

#173				JMPCN	$label11	{LNXT:53|54|56}
(-) BOOL
06A6468D  84 C0                         test al, al
06A6468F  90 74 11 90 90 90             je 06A646A3H

#174		
#175				(* THEN *)
#176		
#177					(* Motor_A := False; *)
#178					MOVE		False,Motor_A	{LNXT:54|56|-1}
(*) BOOL
06A64695  B8 00 00 00 00                mov eax, 00H
06A6469A  84 C0                         test al, al
06A6469C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#179		
#180		$label11:
#181				(* END_IF *)
#182		
#183		
#184				(* IF Fault_B or NOT Avto_B *)
#185				LD		Avto_B	{LNXT:56|-1|-1}
(*) UNDEF
06A646A3  33 C0                         xor eax, eax
06A646A5  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32

#186				NOT	{LNXT:56|-1|-1}
(*) BOOL
06A646AB  84 C0                         test al, al
06A646AD  0F 94 C0                      sete al

#187				OR		Fault_B	{LNXT:56|-1|-1}
(*) BOOL
06A646B0  33 C9                         xor ecx, ecx
06A646B2  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+31
06A646B8  0B C1                         or eax, ecx

#188				JMPCN	$label12	{LNXT:56|57|59}
(-) BOOL
06A646BA  84 C0                         test al, al
06A646BC  90 74 11 90 90 90             je 06A646D0H

#189		
#190				(* THEN *)
#191		
#192					(* Motor_B := False; *)
#193					MOVE		False,Motor_B	{LNXT:57|59|-1}
(*) BOOL
06A646C2  B8 00 00 00 00                mov eax, 00H
06A646C7  84 C0                         test al, al
06A646C9  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#194		
#195		$label12:
#196				(* END_IF *)
#197		
#198		
#199				(* IF Fault_C or NOT Avto_C *)
#200				LD		Avto_C	{LNXT:59|-1|-1}
(*) UNDEF
06A646D0  33 C0                         xor eax, eax
06A646D2  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34

#201				NOT	{LNXT:59|-1|-1}
(*) BOOL
06A646D8  84 C0                         test al, al
06A646DA  0F 94 C0                      sete al

#202				OR		Fault_C	{LNXT:59|-1|-1}
(*) BOOL
06A646DD  33 C9                         xor ecx, ecx
06A646DF  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+33
06A646E5  0B C1                         or eax, ecx

#203				JMPCN	$label13	{LNXT:59|60|70}
(-) BOOL
06A646E7  84 C0                         test al, al
06A646E9  90 74 11 90 90 90             je 06A646FDH

#204		
#205				(* THEN *)
#206		
#207					(* Motor_C := False; *)
#208					MOVE		False,Motor_C	{LNXT:60|70|-1}
(*) BOOL
06A646EF  B8 00 00 00 00                mov eax, 00H
06A646F4  84 C0                         test al, al
06A646F6  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#209		
#210		$label13:
#211				(* END_IF *)
#212		
#213		$label3:
#214			(* END_IF *)
#215		
#216		
#217			(* IF Tank_Level >= Max_Level_1 AND NOT RotationMode AND NOT FastRunMode *)
#218			LD		FastRunMode	{LNXT:70|-1|-1}
(*) UNDEF
06A646FD  33 C0                         xor eax, eax
06A646FF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+22

#219			NOT	{LNXT:70|-1|-1}
(*) BOOL
06A64705  84 C0                         test al, al
06A64707  0F 94 C0                      sete al

#220			AND(		RotationMode	{LNXT:70|-1|-1}
(*) BOOL
06A6470A  50                            push eax
06A6470B  33 C0                         xor eax, eax
06A6470D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+17

#221			NOT	{LNXT:70|-1|-1}
(*) BOOL
06A64713  84 C0                         test al, al
06A64715  0F 94 C0                      sete al

#222			AND(		Tank_Level	{LNXT:70|-1|-1}
(*) BOOL
06A64718  50                            push eax
06A64719  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#223			GE		Max_Level_1	{LNXT:70|-1|-1}
(*) INT
06A64720  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A64727  3B C1                         cmp eax, ecx
06A64729  0F 9D C0                      setge al
06A6472C  25 FF 00 00 00                and eax, 0FFh

#224			)	{LNXT:70|-1|-1}
(*) BOOL
06A64731  8B C8                         mov ecx, eax
06A64733  58                            pop eax
06A64734  23 C1                         and eax, ecx

#225			)	{LNXT:70|-1|-1}
(*) BOOL
06A64736  8B C8                         mov ecx, eax
06A64738  58                            pop eax
06A64739  23 C1                         and eax, ecx

#226			JMPCN	$label14	{LNXT:70|73|101}
(-) BOOL
06A6473B  84 C0                         test al, al
06A6473D  0F 84 E3 01 00 00             je 06A64926H

#227		
#228			(* THEN *)
#229		
#230		
#231				(* CASE PriorityMotor OF *)
#232		
#233				(* 0: *)
#234				LD		PriorityMotor	{LNXT:73|-1|-1}
(*) UNDEF
06A64743  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+20

#235				EQ		0	{LNXT:73|-1|-1}
(*) INT
06A6474A  3D 00 00 00 00                cmp eax, 0
06A6474F  0F 94 C0                      sete al
06A64752  25 FF 00 00 00                and eax, 0FFh

#236				JMPC		$label16	{LNXT:73|74|77}
(-) BOOL
06A64757  84 C0                         test al, al
06A64759  90 75 40 90 90 90             jne 06A6479CH

#237		
#238				(* 1: *)
#239				LD		PriorityMotor	{LNXT:77|-1|-1}
(*) UNDEF
06A6475F  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+20

#240				EQ		1	{LNXT:77|-1|-1}
(*) INT
06A64766  3D 01 00 00 00                cmp eax, 1
06A6476B  0F 94 C0                      sete al
06A6476E  25 FF 00 00 00                and eax, 0FFh

#241				JMPC		$label17	{LNXT:77|78|81}
(-) BOOL
06A64773  84 C0                         test al, al
06A64775  90 75 7C 90 90 90             jne 06A647F4H

#242		
#243				(* 2: *)
#244				LD		PriorityMotor	{LNXT:81|-1|-1}
(*) UNDEF
06A6477B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+20

#245				EQ		2	{LNXT:81|-1|-1}
(*) INT
06A64782  3D 02 00 00 00                cmp eax, 2
06A64787  0F 94 C0                      sete al
06A6478A  25 FF 00 00 00                and eax, 0FFh

#246				JMPC		$label18	{LNXT:81|82|87}
(-) BOOL
06A6478F  84 C0                         test al, al
06A64791  0F 85 B5 00 00 00             jne 06A6484CH

#247				JMP		$label15	{LNXT:81|82|87}
(-) BOOL
06A64797  E9 03 01 00 00                jmp 06A6489FH

#248		
#249				(* Istruzioni di ciascun CASE: *)
#250		
#251		$label16:
#252		
#253					(* IF Fault_A AND Avto_A AND NOT Motor_B AND NOT Motor_C *)
#254					LD		Motor_C	{LNXT:74|-1|-1}
(*) UNDEF
06A6479C  33 C0                         xor eax, eax
06A6479E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#255					NOT	{LNXT:74|-1|-1}
(*) BOOL
06A647A4  84 C0                         test al, al
06A647A6  0F 94 C0                      sete al

#256					AND(		Motor_B	{LNXT:74|-1|-1}
(*) BOOL
06A647A9  50                            push eax
06A647AA  33 C0                         xor eax, eax
06A647AC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#257					NOT	{LNXT:74|-1|-1}
(*) BOOL
06A647B2  84 C0                         test al, al
06A647B4  0F 94 C0                      sete al

#258					AND(		Fault_A	{LNXT:74|-1|-1}
(*) BOOL
06A647B7  50                            push eax
06A647B8  33 C0                         xor eax, eax
06A647BA  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+23

#259					NOT	{LNXT:74|-1|-1}
(*) BOOL
06A647C0  84 C0                         test al, al
06A647C2  0F 94 C0                      sete al

#260					AND		Avto_A	{LNXT:74|-1|-1}
(*) BOOL
06A647C5  33 C9                         xor ecx, ecx
06A647C7  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+30
06A647CD  23 C1                         and eax, ecx

#261					)	{LNXT:74|-1|-1}
(*) BOOL
06A647CF  8B C8                         mov ecx, eax
06A647D1  58                            pop eax
06A647D2  23 C1                         and eax, ecx

#262					)	{LNXT:74|-1|-1}
(*) BOOL
06A647D4  8B C8                         mov ecx, eax
06A647D6  58                            pop eax
06A647D7  23 C1                         and eax, ecx

#263					JMPCN	$label19	{LNXT:74|75|87}
(-) BOOL
06A647D9  84 C0                         test al, al
06A647DB  90 74 11 90 90 90             je 06A647EFH

#264		
#265					(* THEN *)
#266		
#267						(* Motor_A := TRUE; *)
#268						MOVE		TRUE,Motor_A	{LNXT:75|87|-1}
(*) BOOL
06A647E1  B8 01 00 00 00                mov eax, 01H
06A647E6  84 C0                         test al, al
06A647E8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#269		
#270		$label19:
#271					(* END_IF *)
#272					JMP		$label15	{LNXT:1|87|-1}
(-) BOOL
06A647EF  E9 AB 00 00 00                jmp 06A6489FH

#273		
#274		$label17:
#275		
#276					(* IF Fault_B AND Avto_B AND NOT Motor_A AND NOT Motor_C *)
#277					LD		Motor_C	{LNXT:78|-1|-1}
(*) UNDEF
06A647F4  33 C0                         xor eax, eax
06A647F6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#278					NOT	{LNXT:78|-1|-1}
(*) BOOL
06A647FC  84 C0                         test al, al
06A647FE  0F 94 C0                      sete al

#279					AND(		Motor_A	{LNXT:78|-1|-1}
(*) BOOL
06A64801  50                            push eax
06A64802  33 C0                         xor eax, eax
06A64804  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#280					NOT	{LNXT:78|-1|-1}
(*) BOOL
06A6480A  84 C0                         test al, al
06A6480C  0F 94 C0                      sete al

#281					AND(		Fault_B	{LNXT:78|-1|-1}
(*) BOOL
06A6480F  50                            push eax
06A64810  33 C0                         xor eax, eax
06A64812  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31

#282					NOT	{LNXT:78|-1|-1}
(*) BOOL
06A64818  84 C0                         test al, al
06A6481A  0F 94 C0                      sete al

#283					AND		Avto_B	{LNXT:78|-1|-1}
(*) BOOL
06A6481D  33 C9                         xor ecx, ecx
06A6481F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+32
06A64825  23 C1                         and eax, ecx

#284					)	{LNXT:78|-1|-1}
(*) BOOL
06A64827  8B C8                         mov ecx, eax
06A64829  58                            pop eax
06A6482A  23 C1                         and eax, ecx

#285					)	{LNXT:78|-1|-1}
(*) BOOL
06A6482C  8B C8                         mov ecx, eax
06A6482E  58                            pop eax
06A6482F  23 C1                         and eax, ecx

#286					JMPCN	$label20	{LNXT:78|79|87}
(-) BOOL
06A64831  84 C0                         test al, al
06A64833  90 74 11 90 90 90             je 06A64847H

#287		
#288					(* THEN *)
#289		
#290						(* Motor_B := TRUE; *)
#291						MOVE		TRUE,Motor_B	{LNXT:79|87|-1}
(*) BOOL
06A64839  B8 01 00 00 00                mov eax, 01H
06A6483E  84 C0                         test al, al
06A64840  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#292		
#293		$label20:
#294					(* END_IF *)
#295					JMP		$label15	{LNXT:1|87|-1}
(-) BOOL
06A64847  EB 56 90 90 90                jmp 06A6489FH

#296		
#297		$label18:
#298		
#299					(* IF Fault_C AND Avto_C AND NOT Motor_A AND NOT Motor_B *)
#300					LD		Motor_B	{LNXT:82|-1|-1}
(*) UNDEF
06A6484C  33 C0                         xor eax, eax
06A6484E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#301					NOT	{LNXT:82|-1|-1}
(*) BOOL
06A64854  84 C0                         test al, al
06A64856  0F 94 C0                      sete al

#302					AND(		Motor_A	{LNXT:82|-1|-1}
(*) BOOL
06A64859  50                            push eax
06A6485A  33 C0                         xor eax, eax
06A6485C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#303					NOT	{LNXT:82|-1|-1}
(*) BOOL
06A64862  84 C0                         test al, al
06A64864  0F 94 C0                      sete al

#304					AND(		Fault_C	{LNXT:82|-1|-1}
(*) BOOL
06A64867  50                            push eax
06A64868  33 C0                         xor eax, eax
06A6486A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33

#305					NOT	{LNXT:82|-1|-1}
(*) BOOL
06A64870  84 C0                         test al, al
06A64872  0F 94 C0                      sete al

#306					AND		Avto_C	{LNXT:82|-1|-1}
(*) BOOL
06A64875  33 C9                         xor ecx, ecx
06A64877  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+34
06A6487D  23 C1                         and eax, ecx

#307					)	{LNXT:82|-1|-1}
(*) BOOL
06A6487F  8B C8                         mov ecx, eax
06A64881  58                            pop eax
06A64882  23 C1                         and eax, ecx

#308					)	{LNXT:82|-1|-1}
(*) BOOL
06A64884  8B C8                         mov ecx, eax
06A64886  58                            pop eax
06A64887  23 C1                         and eax, ecx

#309					JMPCN	$label21	{LNXT:82|83|87}
(-) BOOL
06A64889  84 C0                         test al, al
06A6488B  90 74 11 90 90 90             je 06A6489FH

#310		
#311					(* THEN *)
#312		
#313						(* Motor_C := TRUE; *)
#314						MOVE		TRUE,Motor_C	{LNXT:83|87|-1}
(*) BOOL
06A64891  B8 01 00 00 00                mov eax, 01H
06A64896  84 C0                         test al, al
06A64898  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#315		
#316		$label21:
#317					(* END_IF *)
#318		
#319		$label15:
#320		
#321				(* END_CASE *)
#322		
#323		
#324				(* IF Fault_A or NOT Avto_A *)
#325				LD		Avto_A	{LNXT:87|-1|-1}
(*) UNDEF
06A6489F  33 C0                         xor eax, eax
06A648A1  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30

#326				NOT	{LNXT:87|-1|-1}
(*) BOOL
06A648A7  84 C0                         test al, al
06A648A9  0F 94 C0                      sete al

#327				OR		Fault_A	{LNXT:87|-1|-1}
(*) BOOL
06A648AC  33 C9                         xor ecx, ecx
06A648AE  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+23
06A648B4  0B C1                         or eax, ecx

#328				JMPCN	$label22	{LNXT:87|88|90}
(-) BOOL
06A648B6  84 C0                         test al, al
06A648B8  90 74 11 90 90 90             je 06A648CCH

#329		
#330				(* THEN *)
#331		
#332					(* Motor_A := False; *)
#333					MOVE		False,Motor_A	{LNXT:88|90|-1}
(*) BOOL
06A648BE  B8 00 00 00 00                mov eax, 00H
06A648C3  84 C0                         test al, al
06A648C5  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#334		
#335		$label22:
#336				(* END_IF *)
#337		
#338		
#339				(* IF Fault_B or NOT Avto_B *)
#340				LD		Avto_B	{LNXT:90|-1|-1}
(*) UNDEF
06A648CC  33 C0                         xor eax, eax
06A648CE  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32

#341				NOT	{LNXT:90|-1|-1}
(*) BOOL
06A648D4  84 C0                         test al, al
06A648D6  0F 94 C0                      sete al

#342				OR		Fault_B	{LNXT:90|-1|-1}
(*) BOOL
06A648D9  33 C9                         xor ecx, ecx
06A648DB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+31
06A648E1  0B C1                         or eax, ecx

#343				JMPCN	$label23	{LNXT:90|91|93}
(-) BOOL
06A648E3  84 C0                         test al, al
06A648E5  90 74 11 90 90 90             je 06A648F9H

#344		
#345				(* THEN *)
#346		
#347					(* Motor_B := False; *)
#348					MOVE		False,Motor_B	{LNXT:91|93|-1}
(*) BOOL
06A648EB  B8 00 00 00 00                mov eax, 00H
06A648F0  84 C0                         test al, al
06A648F2  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#349		
#350		$label23:
#351				(* END_IF *)
#352		
#353		
#354				(* IF Fault_C or NOT Avto_C *)
#355				LD		Avto_C	{LNXT:93|-1|-1}
(*) UNDEF
06A648F9  33 C0                         xor eax, eax
06A648FB  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34

#356				NOT	{LNXT:93|-1|-1}
(*) BOOL
06A64901  84 C0                         test al, al
06A64903  0F 94 C0                      sete al

#357				OR		Fault_C	{LNXT:93|-1|-1}
(*) BOOL
06A64906  33 C9                         xor ecx, ecx
06A64908  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+33
06A6490E  0B C1                         or eax, ecx

#358				JMPCN	$label24	{LNXT:93|94|101}
(-) BOOL
06A64910  84 C0                         test al, al
06A64912  90 74 11 90 90 90             je 06A64926H

#359		
#360				(* THEN *)
#361		
#362					(* Motor_C := False; *)
#363					MOVE		False,Motor_C	{LNXT:94|101|-1}
(*) BOOL
06A64918  B8 00 00 00 00                mov eax, 00H
06A6491D  84 C0                         test al, al
06A6491F  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#364		
#365		$label24:
#366				(* END_IF *)
#367		
#368		$label14:
#369			(* END_IF *)
#370		
#371		
#372			(* IF RotationMode AND FastRunMode *)
#373			LD		RotationMode	{LNXT:101|-1|-1}
(*) UNDEF
06A64926  33 C0                         xor eax, eax
06A64928  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+17

#374			NOT	{LNXT:101|-1|-1}
(*) BOOL
06A6492E  84 C0                         test al, al
06A64930  0F 94 C0                      sete al

#375			AND		FastRunMode	{LNXT:101|-1|-1}
(*) BOOL
06A64933  33 C9                         xor ecx, ecx
06A64935  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+22
06A6493B  23 C1                         and eax, ecx

#376			JMPCN	$label25	{LNXT:101|104|222}
(-) BOOL
06A6493D  84 C0                         test al, al
06A6493F  0F 84 77 07 00 00             je 06A650BCH

#377		
#378			(* THEN *)
#379		
#380		
#381				(* CASE CurrentPump OF *)
#382		
#383				(* 1: *)
#384				LD		CurrentPump	{LNXT:105|-1|-1}
(*) UNDEF
06A64945  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#385				EQ		1	{LNXT:105|-1|-1}
(*) INT
06A6494C  3D 01 00 00 00                cmp eax, 1
06A64951  0F 94 C0                      sete al
06A64954  25 FF 00 00 00                and eax, 0FFh

#386				JMPC		$label27	{LNXT:105|108|140}
(-) BOOL
06A64959  84 C0                         test al, al
06A6495B  90 75 40 90 90 90             jne 06A6499EH

#387		
#388				(* 2: *)
#389				LD		CurrentPump	{LNXT:140|-1|-1}
(*) UNDEF
06A64961  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#390				EQ		2	{LNXT:140|-1|-1}
(*) INT
06A64968  3D 02 00 00 00                cmp eax, 2
06A6496D  0F 94 C0                      sete al
06A64970  25 FF 00 00 00                and eax, 0FFh

#391				JMPC		$label28	{LNXT:140|141|171}
(-) BOOL
06A64975  84 C0                         test al, al
06A64977  0F 85 55 02 00 00             jne 06A64BD2H

#392		
#393				(* 3: *)
#394				LD		CurrentPump	{LNXT:171|-1|-1}
(*) UNDEF
06A6497D  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#395				EQ		3	{LNXT:171|-1|-1}
(*) INT
06A64984  3D 03 00 00 00                cmp eax, 3
06A64989  0F 94 C0                      sete al
06A6498C  25 FF 00 00 00                and eax, 0FFh

#396				JMPC		$label29	{LNXT:171|172|205}
(-) BOOL
06A64991  84 C0                         test al, al
06A64993  0F 85 6D 04 00 00             jne 06A64E06H

#397				JMP		$label26	{LNXT:171|172|205}
(-) BOOL
06A64999  E9 97 06 00 00                jmp 06A65035H

#398		
#399				(* Istruzioni di ciascun CASE: *)
#400		
#401		$label27:
#402		
#403					(* IF Tank_Level >= Max_Level_1 AND PriorityMotor = 0 *)
#404					LD		PriorityMotor	{LNXT:108|-1|-1}
(*) UNDEF
06A6499E  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+20

#405					EQ		0	{LNXT:108|-1|-1}
(*) INT
06A649A5  3D 00 00 00 00                cmp eax, 0
06A649AA  0F 94 C0                      sete al
06A649AD  25 FF 00 00 00                and eax, 0FFh

#406					AND(		Tank_Level	{LNXT:108|-1|-1}
(*) BOOL
06A649B2  50                            push eax
06A649B3  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#407					GE		Max_Level_1	{LNXT:108|-1|-1}
(*) INT
06A649BA  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A649C1  3B C1                         cmp eax, ecx
06A649C3  0F 9D C0                      setge al
06A649C6  25 FF 00 00 00                and eax, 0FFh

#408					)	{LNXT:108|-1|-1}
(*) BOOL
06A649CB  8B C8                         mov ecx, eax
06A649CD  58                            pop eax
06A649CE  23 C1                         and eax, ecx

#409					JMPCN	$label30	{LNXT:108|109|112}
(-) BOOL
06A649D0  84 C0                         test al, al
06A649D2  90 74 33 90 90 90             je 06A64A08H

#410		
#411					(* THEN *)
#412		
#413						(* CurrentPump := ((CurrentPump) MOD 3) + 1; *)
#414						LD		CurrentPump	{LNXT:109|110|-1}
(*) UNDEF
06A649D8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#415						MOD		3	{LNXT:109|110|-1}
(*) INT
06A649DF  99                            cdq
06A649E0  B9 03 00 00 00                mov ecx, 3
06A649E5  F7 F9                         idiv ecx
06A649E7  8B C2                         mov eax, edx

#416						ADD		1	{LNXT:109|110|-1}
(*) INT
06A649E9  05 01 00 00 00                add eax, 1

#417						ST		CurrentPump	{LNXT:109|110|-1}
(*) INT
06A649EE  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#418		
#419						(* Motor_A := TRUE; *)
#420						MOVE		TRUE,Motor_A	{LNXT:110|121|-1}
(*) INT
06A649F5  B8 01 00 00 00                mov eax, 01H
06A649FA  84 C0                         test al, al
06A649FC  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#421						JMP		$label31	{LNXT:108|109|112}
(-) BOOL
06A64A03  E9 85 00 00 00                jmp 06A64A8DH

#422		$label30:
#423		
#424					(* ELSE *)
#425		
#426		
#427						(* IF TestRunActive_1 AND NOT TestRunRunning_1 *)
#428						LD		TestRunRunning_1	{LNXT:112|-1|-1}
(*) UNDEF
06A64A08  33 C0                         xor eax, eax
06A64A0A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35

#429						NOT	{LNXT:112|-1|-1}
(*) BOOL
06A64A10  84 C0                         test al, al
06A64A12  0F 94 C0                      sete al

#430						AND(		TestRunActive_1	{LNXT:112|-1|-1}
(*) BOOL
06A64A15  50                            push eax
06A64A16  33 C0                         xor eax, eax
06A64A18  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+38

#431						NOT	{LNXT:112|-1|-1}
(*) BOOL
06A64A1E  84 C0                         test al, al
06A64A20  0F 94 C0                      sete al

#432						)	{LNXT:112|-1|-1}
(*) BOOL
06A64A23  8B C8                         mov ecx, eax
06A64A25  58                            pop eax
06A64A26  23 C1                         and eax, ecx

#433						JMPCN	$label32	{LNXT:112|113|121}
(-) BOOL
06A64A28  84 C0                         test al, al
06A64A2A  90 74 60 90 90 90             je 06A64A8DH

#434		
#435						(* THEN *)
#436		
#437							(* PumpIntervalTimer_1 *)
#438							MOVE		TRUE,PumpIntervalTimer_1.IN	{LNXT:113|-1|-1}
(*) BOOL
06A64A30  B8 01 00 00 00                mov eax, 01H
06A64A35  84 C0                         test al, al
06A64A37  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+44

#439							MOVE		5000,PumpIntervalTimer_1.PT	{LNXT:113|-1|-1}
(*) BOOL
06A64A3E  B8 88 13 00 00                mov eax, 1388H
06A64A43  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+45

#440							CAL		PumpIntervalTimer_1	{LNXT:113|114|-1}
(*) UDINT
06A64A49  50                            push eax
06A64A4A  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+40
06A64A4F  E8 9C F8 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64A54  58                            pop eax

#441		
#442		
#443							(* IF PumpIntervalTimer_1.Q *)
#444							LD		PumpIntervalTimer_1.Q	{LNXT:114|-1|-1}
(*) UNDEF
06A64A55  33 C0                         xor eax, eax
06A64A57  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+49

#445							JMPCN	$label33	{LNXT:114|115|121}
(-) BOOL
06A64A5D  84 C0                         test al, al
06A64A5F  90 74 2B 90 90 90             je 06A64A8DH

#446		
#447							(* THEN *)
#448		
#449								(* TestRunActive_1 := TRUE; *)
#450								MOVE		TRUE,TestRunActive_1	{LNXT:115|116|-1}
(*) BOOL
06A64A65  B8 01 00 00 00                mov eax, 01H
06A64A6A  84 C0                         test al, al
06A64A6C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+38

#451		
#452								(* PumpIntervalTimer_1 *)
#453								MOVE		FALSE,PumpIntervalTimer_1.IN	{LNXT:116|-1|-1}
(*) BOOL
06A64A73  B8 00 00 00 00                mov eax, 00H
06A64A78  84 C0                         test al, al
06A64A7A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+44

#454								CAL		PumpIntervalTimer_1	{LNXT:116|121|-1}
(*) BOOL
06A64A81  50                            push eax
06A64A82  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+40
06A64A87  E8 64 F8 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64A8C  58                            pop eax

#455		
#456		$label33:
#457							(* END_IF *)
#458		
#459		$label32:
#460						(* END_IF *)
#461		
#462		$label31:
#463					(* END_IF *)
#464		
#465		
#466					(* IF TestRunActive_1 *)
#467					LD		TestRunActive_1	{LNXT:121|-1|-1}
(*) UNDEF
06A64A8D  33 C0                         xor eax, eax
06A64A8F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+38

#468					JMPCN	$label34	{LNXT:121|122|205}
(-) BOOL
06A64A95  84 C0                         test al, al
06A64A97  0F 84 30 01 00 00             je 06A64BCDH

#469		
#470					(* THEN *)
#471		
#472		
#473						(* IF TestRunRunning_1 *)
#474						LD		TestRunRunning_1	{LNXT:122|-1|-1}
(*) UNDEF
06A64A9D  33 C0                         xor eax, eax
06A64A9F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+35

#475						NOT	{LNXT:122|-1|-1}
(*) BOOL
06A64AA5  84 C0                         test al, al
06A64AA7  0F 94 C0                      sete al

#476						JMPCN	$label35	{LNXT:122|123|126}
(-) BOOL
06A64AAA  84 C0                         test al, al
06A64AAC  90 74 11 90 90 90             je 06A64AC0H

#477		
#478						(* THEN *)
#479		
#480							(* TestRunRunning_1 := TRUE; *)
#481							MOVE		TRUE,TestRunRunning_1	{LNXT:123|126|-1}
(*) BOOL
06A64AB2  B8 01 00 00 00                mov eax, 01H
06A64AB7  84 C0                         test al, al
06A64AB9  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#482		
#483		$label35:
#484						(* END_IF *)
#485		
#486		
#487						(* IF TestRunRunning_1 AND Tank_Level < Max_Level_2 And Not Fault_A AND Avto_A *)
#488						LD		Fault_A	{LNXT:126|-1|-1}
(*) UNDEF
06A64AC0  33 C0                         xor eax, eax
06A64AC2  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+23

#489						NOT	{LNXT:126|-1|-1}
(*) BOOL
06A64AC8  84 C0                         test al, al
06A64ACA  0F 94 C0                      sete al

#490						AND(		Tank_Level	{LNXT:126|-1|-1}
(*) BOOL
06A64ACD  50                            push eax
06A64ACE  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#491						LT		Max_Level_2	{LNXT:126|-1|-1}
(*) INT
06A64AD5  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+62
06A64ADC  3B C1                         cmp eax, ecx
06A64ADE  0F 9C C0                      setl al
06A64AE1  25 FF 00 00 00                and eax, 0FFh

#492						AND		TestRunRunning_1	{LNXT:126|-1|-1}
(*) BOOL
06A64AE6  33 C9                         xor ecx, ecx
06A64AE8  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+35
06A64AEE  23 C1                         and eax, ecx

#493						)	{LNXT:126|-1|-1}
(*) BOOL
06A64AF0  8B C8                         mov ecx, eax
06A64AF2  58                            pop eax
06A64AF3  23 C1                         and eax, ecx

#494						AND		Avto_A	{LNXT:126|-1|-1}
(*) BOOL
06A64AF5  33 C9                         xor ecx, ecx
06A64AF7  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+30
06A64AFD  23 C1                         and eax, ecx

#495						JMPCN	$label36	{LNXT:126|127|205}
(-) BOOL
06A64AFF  84 C0                         test al, al
06A64B01  0F 84 C6 00 00 00             je 06A64BCDH

#496		
#497						(* THEN *)
#498		
#499							(* PumpRunTimer_1 *)
#500							LD		TestRunActive_1	{LNXT:127|-1|-1}
(*) UNDEF
06A64B07  33 C0                         xor eax, eax
06A64B09  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+38

#501							AND		TestRunRunning_1	{LNXT:127|-1|-1}
(*) BOOL
06A64B0F  33 C9                         xor ecx, ecx
06A64B11  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+35
06A64B17  23 C1                         and eax, ecx

#502							ST		PumpRunTimer_1.IN	{LNXT:127|-1|-1}
(*) BOOL
06A64B19  84 C0                         test al, al
06A64B1B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+68

#503							MOVE		5000,PumpRunTimer_1.PT	{LNXT:127|-1|-1}
(*) BOOL
06A64B22  B8 88 13 00 00                mov eax, 1388H
06A64B27  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+69

#504							CAL		PumpRunTimer_1	{LNXT:127|128|-1}
(*) UDINT
06A64B2D  50                            push eax
06A64B2E  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+64
06A64B33  E8 B8 F7 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64B38  58                            pop eax

#505		
#506		
#507							(* IF PumpRunTimer_1.Q *)
#508							LD		PumpRunTimer_1.Q	{LNXT:128|-1|-1}
(*) UNDEF
06A64B39  33 C0                         xor eax, eax
06A64B3B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+73

#509							NOT	{LNXT:128|-1|-1}
(*) BOOL
06A64B41  84 C0                         test al, al
06A64B43  0F 94 C0                      sete al

#510							JMPCN	$label37	{LNXT:128|129|131}
(-) BOOL
06A64B46  84 C0                         test al, al
06A64B48  90 74 16 90 90 90             je 06A64B61H

#511		
#512							(* THEN *)
#513		
#514								(* Motor_A := TRUE; *)
#515								MOVE		TRUE,Motor_A	{LNXT:129|205|-1}
(*) BOOL
06A64B4E  B8 01 00 00 00                mov eax, 01H
06A64B53  84 C0                         test al, al
06A64B55  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#516								JMP		$label38	{LNXT:128|129|131}
(-) BOOL
06A64B5C  EB 6F 90 90 90                jmp 06A64BCDH

#517		$label37:
#518		
#519							(* ELSE *)
#520		
#521								(* Motor_A := FALSE; *)
#522								MOVE		FALSE,Motor_A	{LNXT:131|132|-1}
(*) BOOL
06A64B61  B8 00 00 00 00                mov eax, 00H
06A64B66  84 C0                         test al, al
06A64B68  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#523		
#524								(* TestRunRunning_1 := FALSE; *)
#525								MOVE		FALSE,TestRunRunning_1	{LNXT:132|133|-1}
(*) BOOL
06A64B6F  B8 00 00 00 00                mov eax, 00H
06A64B74  84 C0                         test al, al
06A64B76  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+35

#526		
#527								(* TestRunActive_1 := FALSE; *)
#528								MOVE		FALSE,TestRunActive_1	{LNXT:133|134|-1}
(*) BOOL
06A64B7D  B8 00 00 00 00                mov eax, 00H
06A64B82  84 C0                         test al, al
06A64B84  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+38

#529		
#530								(* PumpRunTimer_1 *)
#531								MOVE		FALSE,PumpRunTimer_1.IN	{LNXT:134|-1|-1}
(*) BOOL
06A64B8B  B8 00 00 00 00                mov eax, 00H
06A64B90  84 C0                         test al, al
06A64B92  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+68

#532								MOVE		5000,PumpRunTimer_1.PT	{LNXT:134|-1|-1}
(*) BOOL
06A64B99  B8 88 13 00 00                mov eax, 1388H
06A64B9E  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+69

#533								CAL		PumpRunTimer_1	{LNXT:134|135|-1}
(*) UDINT
06A64BA4  50                            push eax
06A64BA5  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+64
06A64BAA  E8 41 F7 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64BAF  58                            pop eax

#534		
#535								(* CurrentPump := ((CurrentPump) MOD 3) + 1; *)
#536								LD		CurrentPump	{LNXT:135|205|-1}
(*) UNDEF
06A64BB0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#537								MOD		3	{LNXT:135|205|-1}
(*) INT
06A64BB7  99                            cdq
06A64BB8  B9 03 00 00 00                mov ecx, 3
06A64BBD  F7 F9                         idiv ecx
06A64BBF  8B C2                         mov eax, edx

#538								ADD		1	{LNXT:135|205|-1}
(*) INT
06A64BC1  05 01 00 00 00                add eax, 1

#539								ST		CurrentPump	{LNXT:135|205|-1}
(*) INT
06A64BC6  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#540		
#541		$label38:
#542							(* END_IF *)
#543		
#544		$label36:
#545						(* END_IF *)
#546		
#547		$label34:
#548					(* END_IF *)
#549					JMP		$label26	{LNXT:1|205|-1}
(-) INT
06A64BCD  E9 63 04 00 00                jmp 06A65035H

#550		
#551		$label28:
#552		
#553					(* IF Tank_Level >= Max_Level_1 AND PriorityMotor = 1 *)
#554					LD		PriorityMotor	{LNXT:141|-1|-1}
(*) UNDEF
06A64BD2  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+20

#555					EQ		1	{LNXT:141|-1|-1}
(*) INT
06A64BD9  3D 01 00 00 00                cmp eax, 1
06A64BDE  0F 94 C0                      sete al
06A64BE1  25 FF 00 00 00                and eax, 0FFh

#556					AND(		Tank_Level	{LNXT:141|-1|-1}
(*) BOOL
06A64BE6  50                            push eax
06A64BE7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#557					GE		Max_Level_1	{LNXT:141|-1|-1}
(*) INT
06A64BEE  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A64BF5  3B C1                         cmp eax, ecx
06A64BF7  0F 9D C0                      setge al
06A64BFA  25 FF 00 00 00                and eax, 0FFh

#558					)	{LNXT:141|-1|-1}
(*) BOOL
06A64BFF  8B C8                         mov ecx, eax
06A64C01  58                            pop eax
06A64C02  23 C1                         and eax, ecx

#559					JMPCN	$label39	{LNXT:141|142|145}
(-) BOOL
06A64C04  84 C0                         test al, al
06A64C06  90 74 33 90 90 90             je 06A64C3CH

#560		
#561					(* THEN *)
#562		
#563						(* CurrentPump := ((CurrentPump) MOD 3) + 1; *)
#564						LD		CurrentPump	{LNXT:142|143|-1}
(*) UNDEF
06A64C0C  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#565						MOD		3	{LNXT:142|143|-1}
(*) INT
06A64C13  99                            cdq
06A64C14  B9 03 00 00 00                mov ecx, 3
06A64C19  F7 F9                         idiv ecx
06A64C1B  8B C2                         mov eax, edx

#566						ADD		1	{LNXT:142|143|-1}
(*) INT
06A64C1D  05 01 00 00 00                add eax, 1

#567						ST		CurrentPump	{LNXT:142|143|-1}
(*) INT
06A64C22  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#568		
#569						(* Motor_B := TRUE; *)
#570						MOVE		TRUE,Motor_B	{LNXT:143|153|-1}
(*) INT
06A64C29  B8 01 00 00 00                mov eax, 01H
06A64C2E  84 C0                         test al, al
06A64C30  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#571						JMP		$label40	{LNXT:141|142|145}
(-) BOOL
06A64C37  E9 85 00 00 00                jmp 06A64CC1H

#572		$label39:
#573		
#574					(* ELSE *)
#575		
#576		
#577						(* IF TestRunActive_2 AND NOT TestRunRunning_2 *)
#578						LD		TestRunRunning_2	{LNXT:145|-1|-1}
(*) UNDEF
06A64C3C  33 C0                         xor eax, eax
06A64C3E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+39

#579						NOT	{LNXT:145|-1|-1}
(*) BOOL
06A64C44  84 C0                         test al, al
06A64C46  0F 94 C0                      sete al

#580						AND(		TestRunActive_2	{LNXT:145|-1|-1}
(*) BOOL
06A64C49  50                            push eax
06A64C4A  33 C0                         xor eax, eax
06A64C4C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+86

#581						NOT	{LNXT:145|-1|-1}
(*) BOOL
06A64C52  84 C0                         test al, al
06A64C54  0F 94 C0                      sete al

#582						)	{LNXT:145|-1|-1}
(*) BOOL
06A64C57  8B C8                         mov ecx, eax
06A64C59  58                            pop eax
06A64C5A  23 C1                         and eax, ecx

#583						JMPCN	$label41	{LNXT:145|146|153}
(-) BOOL
06A64C5C  84 C0                         test al, al
06A64C5E  90 74 60 90 90 90             je 06A64CC1H

#584		
#585						(* THEN *)
#586		
#587							(* PumpIntervalTimer_2 *)
#588							MOVE		TRUE,PumpIntervalTimer_2.IN	{LNXT:146|-1|-1}
(*) BOOL
06A64C64  B8 01 00 00 00                mov eax, 01H
06A64C69  84 C0                         test al, al
06A64C6B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+92

#589							MOVE		6000,PumpIntervalTimer_2.PT	{LNXT:146|-1|-1}
(*) BOOL
06A64C72  B8 70 17 00 00                mov eax, 1770H
06A64C77  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+93

#590							CAL		PumpIntervalTimer_2	{LNXT:146|147|-1}
(*) UDINT
06A64C7D  50                            push eax
06A64C7E  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+88
06A64C83  E8 68 F6 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64C88  58                            pop eax

#591		
#592		
#593							(* IF PumpIntervalTimer_2.Q *)
#594							LD		PumpIntervalTimer_2.Q	{LNXT:147|-1|-1}
(*) UNDEF
06A64C89  33 C0                         xor eax, eax
06A64C8B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+97

#595							JMPCN	$label42	{LNXT:147|148|153}
(-) BOOL
06A64C91  84 C0                         test al, al
06A64C93  90 74 2B 90 90 90             je 06A64CC1H

#596		
#597							(* THEN *)
#598		
#599								(* TestRunActive_2 := TRUE; *)
#600								MOVE		TRUE,TestRunActive_2	{LNXT:148|149|-1}
(*) BOOL
06A64C99  B8 01 00 00 00                mov eax, 01H
06A64C9E  84 C0                         test al, al
06A64CA0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+86

#601		
#602								(* PumpIntervalTimer_2 *)
#603								MOVE		FALSE,PumpIntervalTimer_2.IN	{LNXT:149|-1|-1}
(*) BOOL
06A64CA7  B8 00 00 00 00                mov eax, 00H
06A64CAC  84 C0                         test al, al
06A64CAE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+92

#604								CAL		PumpIntervalTimer_2	{LNXT:149|153|-1}
(*) BOOL
06A64CB5  50                            push eax
06A64CB6  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+88
06A64CBB  E8 30 F6 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64CC0  58                            pop eax

#605		
#606		$label42:
#607							(* END_IF *)
#608		
#609		$label41:
#610						(* END_IF *)
#611		
#612		$label40:
#613					(* END_IF *)
#614		
#615		
#616					(* IF TestRunActive_2 *)
#617					LD		TestRunActive_2	{LNXT:153|-1|-1}
(*) UNDEF
06A64CC1  33 C0                         xor eax, eax
06A64CC3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+86

#618					JMPCN	$label43	{LNXT:153|154|205}
(-) BOOL
06A64CC9  84 C0                         test al, al
06A64CCB  0F 84 30 01 00 00             je 06A64E01H

#619		
#620					(* THEN *)
#621		
#622		
#623						(* IF TestRunRunning_2 *)
#624						LD		TestRunRunning_2	{LNXT:154|-1|-1}
(*) UNDEF
06A64CD1  33 C0                         xor eax, eax
06A64CD3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+39

#625						NOT	{LNXT:154|-1|-1}
(*) BOOL
06A64CD9  84 C0                         test al, al
06A64CDB  0F 94 C0                      sete al

#626						JMPCN	$label44	{LNXT:154|155|157}
(-) BOOL
06A64CDE  84 C0                         test al, al
06A64CE0  90 74 11 90 90 90             je 06A64CF4H

#627		
#628						(* THEN *)
#629		
#630							(* TestRunRunning_2 := TRUE; *)
#631							MOVE		TRUE,TestRunRunning_2	{LNXT:155|157|-1}
(*) BOOL
06A64CE6  B8 01 00 00 00                mov eax, 01H
06A64CEB  84 C0                         test al, al
06A64CED  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+39

#632		
#633		$label44:
#634						(* END_IF *)
#635		
#636		
#637						(* IF TestRunRunning_2 AND Tank_Level < Max_Level_2 And Not Fault_B AND Avto_B *)
#638						LD		Fault_B	{LNXT:157|-1|-1}
(*) UNDEF
06A64CF4  33 C0                         xor eax, eax
06A64CF6  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31

#639						NOT	{LNXT:157|-1|-1}
(*) BOOL
06A64CFC  84 C0                         test al, al
06A64CFE  0F 94 C0                      sete al

#640						AND(		Tank_Level	{LNXT:157|-1|-1}
(*) BOOL
06A64D01  50                            push eax
06A64D02  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#641						LT		Max_Level_2	{LNXT:157|-1|-1}
(*) INT
06A64D09  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+62
06A64D10  3B C1                         cmp eax, ecx
06A64D12  0F 9C C0                      setl al
06A64D15  25 FF 00 00 00                and eax, 0FFh

#642						AND		TestRunRunning_2	{LNXT:157|-1|-1}
(*) BOOL
06A64D1A  33 C9                         xor ecx, ecx
06A64D1C  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+39
06A64D22  23 C1                         and eax, ecx

#643						)	{LNXT:157|-1|-1}
(*) BOOL
06A64D24  8B C8                         mov ecx, eax
06A64D26  58                            pop eax
06A64D27  23 C1                         and eax, ecx

#644						AND		Avto_B	{LNXT:157|-1|-1}
(*) BOOL
06A64D29  33 C9                         xor ecx, ecx
06A64D2B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+32
06A64D31  23 C1                         and eax, ecx

#645						JMPCN	$label45	{LNXT:157|158|205}
(-) BOOL
06A64D33  84 C0                         test al, al
06A64D35  0F 84 C6 00 00 00             je 06A64E01H

#646		
#647						(* THEN *)
#648		
#649							(* PumpRunTimer_2 *)
#650							LD		TestRunActive_2	{LNXT:158|-1|-1}
(*) UNDEF
06A64D3B  33 C0                         xor eax, eax
06A64D3D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+86

#651							AND		TestRunRunning_2	{LNXT:158|-1|-1}
(*) BOOL
06A64D43  33 C9                         xor ecx, ecx
06A64D45  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+39
06A64D4B  23 C1                         and eax, ecx

#652							ST		PumpRunTimer_2.IN	{LNXT:158|-1|-1}
(*) BOOL
06A64D4D  84 C0                         test al, al
06A64D4F  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+114

#653							MOVE		6000,PumpRunTimer_2.PT	{LNXT:158|-1|-1}
(*) BOOL
06A64D56  B8 70 17 00 00                mov eax, 1770H
06A64D5B  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+115

#654							CAL		PumpRunTimer_2	{LNXT:158|159|-1}
(*) UDINT
06A64D61  50                            push eax
06A64D62  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+110
06A64D67  E8 84 F5 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64D6C  58                            pop eax

#655		
#656		
#657							(* IF PumpRunTimer_2.Q *)
#658							LD		PumpRunTimer_2.Q	{LNXT:159|-1|-1}
(*) UNDEF
06A64D6D  33 C0                         xor eax, eax
06A64D6F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+119

#659							NOT	{LNXT:159|-1|-1}
(*) BOOL
06A64D75  84 C0                         test al, al
06A64D77  0F 94 C0                      sete al

#660							JMPCN	$label46	{LNXT:159|160|162}
(-) BOOL
06A64D7A  84 C0                         test al, al
06A64D7C  90 74 16 90 90 90             je 06A64D95H

#661		
#662							(* THEN *)
#663		
#664								(* Motor_B := TRUE; *)
#665								MOVE		TRUE,Motor_B	{LNXT:160|205|-1}
(*) BOOL
06A64D82  B8 01 00 00 00                mov eax, 01H
06A64D87  84 C0                         test al, al
06A64D89  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#666								JMP		$label47	{LNXT:159|160|162}
(-) BOOL
06A64D90  EB 6F 90 90 90                jmp 06A64E01H

#667		$label46:
#668		
#669							(* ELSE *)
#670		
#671								(* Motor_B := FALSE; *)
#672								MOVE		FALSE,Motor_B	{LNXT:162|163|-1}
(*) BOOL
06A64D95  B8 00 00 00 00                mov eax, 00H
06A64D9A  84 C0                         test al, al
06A64D9C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#673		
#674								(* TestRunRunning_2 := FALSE; *)
#675								MOVE		FALSE,TestRunRunning_2	{LNXT:163|164|-1}
(*) BOOL
06A64DA3  B8 00 00 00 00                mov eax, 00H
06A64DA8  84 C0                         test al, al
06A64DAA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+39

#676		
#677								(* TestRunActive_2 := FALSE; *)
#678								MOVE		FALSE,TestRunActive_2	{LNXT:164|165|-1}
(*) BOOL
06A64DB1  B8 00 00 00 00                mov eax, 00H
06A64DB6  84 C0                         test al, al
06A64DB8  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+86

#679		
#680								(* PumpRunTimer_2 *)
#681								MOVE		FALSE,PumpRunTimer_2.IN	{LNXT:165|-1|-1}
(*) BOOL
06A64DBF  B8 00 00 00 00                mov eax, 00H
06A64DC4  84 C0                         test al, al
06A64DC6  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+114

#682								MOVE		6000,PumpRunTimer_2.PT	{LNXT:165|-1|-1}
(*) BOOL
06A64DCD  B8 70 17 00 00                mov eax, 1770H
06A64DD2  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+115

#683								CAL		PumpRunTimer_2	{LNXT:165|166|-1}
(*) UDINT
06A64DD8  50                            push eax
06A64DD9  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+110
06A64DDE  E8 0D F5 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64DE3  58                            pop eax

#684		
#685								(* CurrentPump := ((CurrentPump) MOD 3) + 1; *)
#686								LD		CurrentPump	{LNXT:166|205|-1}
(*) UNDEF
06A64DE4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#687								MOD		3	{LNXT:166|205|-1}
(*) INT
06A64DEB  99                            cdq
06A64DEC  B9 03 00 00 00                mov ecx, 3
06A64DF1  F7 F9                         idiv ecx
06A64DF3  8B C2                         mov eax, edx

#688								ADD		1	{LNXT:166|205|-1}
(*) INT
06A64DF5  05 01 00 00 00                add eax, 1

#689								ST		CurrentPump	{LNXT:166|205|-1}
(*) INT
06A64DFA  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#690		
#691		$label47:
#692							(* END_IF *)
#693		
#694		$label45:
#695						(* END_IF *)
#696		
#697		$label43:
#698					(* END_IF *)
#699					JMP		$label26	{LNXT:1|205|-1}
(-) INT
06A64E01  E9 2F 02 00 00                jmp 06A65035H

#700		
#701		$label29:
#702		
#703					(* IF Tank_Level >= Max_Level_1 AND PriorityMotor = 2 *)
#704					LD		PriorityMotor	{LNXT:172|-1|-1}
(*) UNDEF
06A64E06  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+20

#705					EQ		2	{LNXT:172|-1|-1}
(*) INT
06A64E0D  3D 02 00 00 00                cmp eax, 2
06A64E12  0F 94 C0                      sete al
06A64E15  25 FF 00 00 00                and eax, 0FFh

#706					AND(		Tank_Level	{LNXT:172|-1|-1}
(*) BOOL
06A64E1A  50                            push eax
06A64E1B  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#707					GE		Max_Level_1	{LNXT:172|-1|-1}
(*) INT
06A64E22  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A64E29  3B C1                         cmp eax, ecx
06A64E2B  0F 9D C0                      setge al
06A64E2E  25 FF 00 00 00                and eax, 0FFh

#708					)	{LNXT:172|-1|-1}
(*) BOOL
06A64E33  8B C8                         mov ecx, eax
06A64E35  58                            pop eax
06A64E36  23 C1                         and eax, ecx

#709					JMPCN	$label48	{LNXT:172|173|176}
(-) BOOL
06A64E38  84 C0                         test al, al
06A64E3A  90 74 33 90 90 90             je 06A64E70H

#710		
#711					(* THEN *)
#712		
#713						(* CurrentPump := ((CurrentPump) MOD 3) + 1; *)
#714						LD		CurrentPump	{LNXT:173|174|-1}
(*) UNDEF
06A64E40  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#715						MOD		3	{LNXT:173|174|-1}
(*) INT
06A64E47  99                            cdq
06A64E48  B9 03 00 00 00                mov ecx, 3
06A64E4D  F7 F9                         idiv ecx
06A64E4F  8B C2                         mov eax, edx

#716						ADD		1	{LNXT:173|174|-1}
(*) INT
06A64E51  05 01 00 00 00                add eax, 1

#717						ST		CurrentPump	{LNXT:173|174|-1}
(*) INT
06A64E56  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#718		
#719						(* Motor_C := TRUE; *)
#720						MOVE		TRUE,Motor_C	{LNXT:174|184|-1}
(*) INT
06A64E5D  B8 01 00 00 00                mov eax, 01H
06A64E62  84 C0                         test al, al
06A64E64  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#721						JMP		$label49	{LNXT:172|173|176}
(-) BOOL
06A64E6B  E9 85 00 00 00                jmp 06A64EF5H

#722		$label48:
#723		
#724					(* ELSE *)
#725		
#726		
#727						(* IF TestRunActive_3 AND NOT TestRunRunning_3 *)
#728						LD		TestRunRunning_3	{LNXT:176|-1|-1}
(*) UNDEF
06A64E70  33 C0                         xor eax, eax
06A64E72  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+87

#729						NOT	{LNXT:176|-1|-1}
(*) BOOL
06A64E78  84 C0                         test al, al
06A64E7A  0F 94 C0                      sete al

#730						AND(		TestRunActive_3	{LNXT:176|-1|-1}
(*) BOOL
06A64E7D  50                            push eax
06A64E7E  33 C0                         xor eax, eax
06A64E80  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+132

#731						NOT	{LNXT:176|-1|-1}
(*) BOOL
06A64E86  84 C0                         test al, al
06A64E88  0F 94 C0                      sete al

#732						)	{LNXT:176|-1|-1}
(*) BOOL
06A64E8B  8B C8                         mov ecx, eax
06A64E8D  58                            pop eax
06A64E8E  23 C1                         and eax, ecx

#733						JMPCN	$label50	{LNXT:176|177|184}
(-) BOOL
06A64E90  84 C0                         test al, al
06A64E92  90 74 60 90 90 90             je 06A64EF5H

#734		
#735						(* THEN *)
#736		
#737							(* PumpIntervalTimer_3 *)
#738							MOVE		TRUE,PumpIntervalTimer_3.IN	{LNXT:177|-1|-1}
(*) BOOL
06A64E98  B8 01 00 00 00                mov eax, 01H
06A64E9D  84 C0                         test al, al
06A64E9F  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+138

#739							MOVE		7000,PumpIntervalTimer_3.PT	{LNXT:177|-1|-1}
(*) BOOL
06A64EA6  B8 58 1B 00 00                mov eax, 1B58H
06A64EAB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+139

#740							CAL		PumpIntervalTimer_3	{LNXT:177|178|-1}
(*) UDINT
06A64EB1  50                            push eax
06A64EB2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+134
06A64EB7  E8 34 F4 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64EBC  58                            pop eax

#741		
#742		
#743							(* IF PumpIntervalTimer_3.Q *)
#744							LD		PumpIntervalTimer_3.Q	{LNXT:178|-1|-1}
(*) UNDEF
06A64EBD  33 C0                         xor eax, eax
06A64EBF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+143

#745							JMPCN	$label51	{LNXT:178|179|184}
(-) BOOL
06A64EC5  84 C0                         test al, al
06A64EC7  90 74 2B 90 90 90             je 06A64EF5H

#746		
#747							(* THEN *)
#748		
#749								(* TestRunActive_3 := TRUE; *)
#750								MOVE		TRUE,TestRunActive_3	{LNXT:179|180|-1}
(*) BOOL
06A64ECD  B8 01 00 00 00                mov eax, 01H
06A64ED2  84 C0                         test al, al
06A64ED4  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+132

#751		
#752								(* PumpIntervalTimer_3 *)
#753								MOVE		FALSE,PumpIntervalTimer_3.IN	{LNXT:180|-1|-1}
(*) BOOL
06A64EDB  B8 00 00 00 00                mov eax, 00H
06A64EE0  84 C0                         test al, al
06A64EE2  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+138

#754								CAL		PumpIntervalTimer_3	{LNXT:180|184|-1}
(*) BOOL
06A64EE9  50                            push eax
06A64EEA  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+134
06A64EEF  E8 FC F3 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64EF4  58                            pop eax

#755		
#756		$label51:
#757							(* END_IF *)
#758		
#759		$label50:
#760						(* END_IF *)
#761		
#762		$label49:
#763					(* END_IF *)
#764		
#765		
#766					(* IF TestRunActive_3 *)
#767					LD		TestRunActive_3	{LNXT:184|-1|-1}
(*) UNDEF
06A64EF5  33 C0                         xor eax, eax
06A64EF7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+132

#768					JMPCN	$label52	{LNXT:184|185|205}
(-) BOOL
06A64EFD  84 C0                         test al, al
06A64EFF  0F 84 30 01 00 00             je 06A65035H

#769		
#770					(* THEN *)
#771		
#772		
#773						(* IF TestRunRunning_3 *)
#774						LD		TestRunRunning_3	{LNXT:185|-1|-1}
(*) UNDEF
06A64F05  33 C0                         xor eax, eax
06A64F07  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+87

#775						NOT	{LNXT:185|-1|-1}
(*) BOOL
06A64F0D  84 C0                         test al, al
06A64F0F  0F 94 C0                      sete al

#776						JMPCN	$label53	{LNXT:185|186|188}
(-) BOOL
06A64F12  84 C0                         test al, al
06A64F14  90 74 11 90 90 90             je 06A64F28H

#777		
#778						(* THEN *)
#779		
#780							(* TestRunRunning_3 := TRUE; *)
#781							MOVE		TRUE,TestRunRunning_3	{LNXT:186|188|-1}
(*) BOOL
06A64F1A  B8 01 00 00 00                mov eax, 01H
06A64F1F  84 C0                         test al, al
06A64F21  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+87

#782		
#783		$label53:
#784						(* END_IF *)
#785		
#786		
#787						(* IF TestRunRunning_3 AND Tank_Level < Max_Level_2 And Not Fault_C AND Avto_C *)
#788						LD		Fault_C	{LNXT:188|-1|-1}
(*) UNDEF
06A64F28  33 C0                         xor eax, eax
06A64F2A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33

#789						NOT	{LNXT:188|-1|-1}
(*) BOOL
06A64F30  84 C0                         test al, al
06A64F32  0F 94 C0                      sete al

#790						AND(		Tank_Level	{LNXT:188|-1|-1}
(*) BOOL
06A64F35  50                            push eax
06A64F36  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#791						LT		Max_Level_2	{LNXT:188|-1|-1}
(*) INT
06A64F3D  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+62
06A64F44  3B C1                         cmp eax, ecx
06A64F46  0F 9C C0                      setl al
06A64F49  25 FF 00 00 00                and eax, 0FFh

#792						AND		TestRunRunning_3	{LNXT:188|-1|-1}
(*) BOOL
06A64F4E  33 C9                         xor ecx, ecx
06A64F50  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+87
06A64F56  23 C1                         and eax, ecx

#793						)	{LNXT:188|-1|-1}
(*) BOOL
06A64F58  8B C8                         mov ecx, eax
06A64F5A  58                            pop eax
06A64F5B  23 C1                         and eax, ecx

#794						AND		Avto_C	{LNXT:188|-1|-1}
(*) BOOL
06A64F5D  33 C9                         xor ecx, ecx
06A64F5F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+34
06A64F65  23 C1                         and eax, ecx

#795						JMPCN	$label54	{LNXT:188|189|205}
(-) BOOL
06A64F67  84 C0                         test al, al
06A64F69  0F 84 C6 00 00 00             je 06A65035H

#796		
#797						(* THEN *)
#798		
#799							(* PumpRunTimer_3 *)
#800							LD		TestRunActive_3	{LNXT:189|-1|-1}
(*) UNDEF
06A64F6F  33 C0                         xor eax, eax
06A64F71  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+132

#801							AND		TestRunRunning_3	{LNXT:189|-1|-1}
(*) BOOL
06A64F77  33 C9                         xor ecx, ecx
06A64F79  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+87
06A64F7F  23 C1                         and eax, ecx

#802							ST		PumpRunTimer_3.IN	{LNXT:189|-1|-1}
(*) BOOL
06A64F81  84 C0                         test al, al
06A64F83  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+160

#803							MOVE		7000,PumpRunTimer_3.PT	{LNXT:189|-1|-1}
(*) BOOL
06A64F8A  B8 58 1B 00 00                mov eax, 1B58H
06A64F8F  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+161

#804							CAL		PumpRunTimer_3	{LNXT:189|190|-1}
(*) UDINT
06A64F95  50                            push eax
06A64F96  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+156
06A64F9B  E8 50 F3 FF FF                call 06A642F0H ; $$CODE$$+17136
06A64FA0  58                            pop eax

#805		
#806		
#807							(* IF PumpRunTimer_3.Q *)
#808							LD		PumpRunTimer_3.Q	{LNXT:190|-1|-1}
(*) UNDEF
06A64FA1  33 C0                         xor eax, eax
06A64FA3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+165

#809							NOT	{LNXT:190|-1|-1}
(*) BOOL
06A64FA9  84 C0                         test al, al
06A64FAB  0F 94 C0                      sete al

#810							JMPCN	$label55	{LNXT:190|191|193}
(-) BOOL
06A64FAE  84 C0                         test al, al
06A64FB0  90 74 16 90 90 90             je 06A64FC9H

#811		
#812							(* THEN *)
#813		
#814								(* Motor_C := TRUE; *)
#815								MOVE		TRUE,Motor_C	{LNXT:191|205|-1}
(*) BOOL
06A64FB6  B8 01 00 00 00                mov eax, 01H
06A64FBB  84 C0                         test al, al
06A64FBD  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#816								JMP		$label56	{LNXT:190|191|193}
(-) BOOL
06A64FC4  EB 6F 90 90 90                jmp 06A65035H

#817		$label55:
#818		
#819							(* ELSE *)
#820		
#821								(* Motor_C := FALSE; *)
#822								MOVE		FALSE,Motor_C	{LNXT:193|194|-1}
(*) BOOL
06A64FC9  B8 00 00 00 00                mov eax, 00H
06A64FCE  84 C0                         test al, al
06A64FD0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#823		
#824								(* TestRunRunning_3 := FALSE; *)
#825								MOVE		FALSE,TestRunRunning_3	{LNXT:194|195|-1}
(*) BOOL
06A64FD7  B8 00 00 00 00                mov eax, 00H
06A64FDC  84 C0                         test al, al
06A64FDE  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+87

#826		
#827								(* TestRunActive_3 := FALSE; *)
#828								MOVE		FALSE,TestRunActive_3	{LNXT:195|196|-1}
(*) BOOL
06A64FE5  B8 00 00 00 00                mov eax, 00H
06A64FEA  84 C0                         test al, al
06A64FEC  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+132

#829		
#830								(* PumpRunTimer_3 *)
#831								MOVE		FALSE,PumpRunTimer_3.IN	{LNXT:196|-1|-1}
(*) BOOL
06A64FF3  B8 00 00 00 00                mov eax, 00H
06A64FF8  84 C0                         test al, al
06A64FFA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+160

#832								MOVE		7000,PumpRunTimer_3.PT	{LNXT:196|-1|-1}
(*) BOOL
06A65001  B8 58 1B 00 00                mov eax, 1B58H
06A65006  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+161

#833								CAL		PumpRunTimer_3	{LNXT:196|197|-1}
(*) UDINT
06A6500C  50                            push eax
06A6500D  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+156
06A65012  E8 D9 F2 FF FF                call 06A642F0H ; $$CODE$$+17136
06A65017  58                            pop eax

#834		
#835								(* CurrentPump := ((CurrentPump) MOD 3) + 1; *)
#836								LD		CurrentPump	{LNXT:197|205|-1}
(*) UNDEF
06A65018  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+36

#837								MOD		3	{LNXT:197|205|-1}
(*) INT
06A6501F  99                            cdq
06A65020  B9 03 00 00 00                mov ecx, 3
06A65025  F7 F9                         idiv ecx
06A65027  8B C2                         mov eax, edx

#838								ADD		1	{LNXT:197|205|-1}
(*) INT
06A65029  05 01 00 00 00                add eax, 1

#839								ST		CurrentPump	{LNXT:197|205|-1}
(*) INT
06A6502E  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; $$DATA$$+36

#840		
#841		$label56:
#842							(* END_IF *)
#843		
#844		$label54:
#845						(* END_IF *)
#846		
#847		$label52:
#848					(* END_IF *)
#849		
#850		$label26:
#851		
#852				(* END_CASE *)
#853		
#854		
#855				(* IF Fault_A or NOT Avto_A *)
#856				LD		Avto_A	{LNXT:205|-1|-1}
(*) UNDEF
06A65035  33 C0                         xor eax, eax
06A65037  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30

#857				NOT	{LNXT:205|-1|-1}
(*) BOOL
06A6503D  84 C0                         test al, al
06A6503F  0F 94 C0                      sete al

#858				OR		Fault_A	{LNXT:205|-1|-1}
(*) BOOL
06A65042  33 C9                         xor ecx, ecx
06A65044  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+23
06A6504A  0B C1                         or eax, ecx

#859				JMPCN	$label57	{LNXT:205|206|208}
(-) BOOL
06A6504C  84 C0                         test al, al
06A6504E  90 74 11 90 90 90             je 06A65062H

#860		
#861				(* THEN *)
#862		
#863					(* Motor_A := False; *)
#864					MOVE		False,Motor_A	{LNXT:206|208|-1}
(*) BOOL
06A65054  B8 00 00 00 00                mov eax, 00H
06A65059  84 C0                         test al, al
06A6505B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#865		
#866		$label57:
#867				(* END_IF *)
#868		
#869		
#870				(* IF Fault_B or NOT Avto_B *)
#871				LD		Avto_B	{LNXT:208|-1|-1}
(*) UNDEF
06A65062  33 C0                         xor eax, eax
06A65064  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32

#872				NOT	{LNXT:208|-1|-1}
(*) BOOL
06A6506A  84 C0                         test al, al
06A6506C  0F 94 C0                      sete al

#873				OR		Fault_B	{LNXT:208|-1|-1}
(*) BOOL
06A6506F  33 C9                         xor ecx, ecx
06A65071  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+31
06A65077  0B C1                         or eax, ecx

#874				JMPCN	$label58	{LNXT:208|209|211}
(-) BOOL
06A65079  84 C0                         test al, al
06A6507B  90 74 11 90 90 90             je 06A6508FH

#875		
#876				(* THEN *)
#877		
#878					(* Motor_B := False; *)
#879					MOVE		False,Motor_B	{LNXT:209|211|-1}
(*) BOOL
06A65081  B8 00 00 00 00                mov eax, 00H
06A65086  84 C0                         test al, al
06A65088  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#880		
#881		$label58:
#882				(* END_IF *)
#883		
#884		
#885				(* IF Fault_C or NOT Avto_C *)
#886				LD		Avto_C	{LNXT:211|-1|-1}
(*) UNDEF
06A6508F  33 C0                         xor eax, eax
06A65091  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34

#887				NOT	{LNXT:211|-1|-1}
(*) BOOL
06A65097  84 C0                         test al, al
06A65099  0F 94 C0                      sete al

#888				OR		Fault_C	{LNXT:211|-1|-1}
(*) BOOL
06A6509C  33 C9                         xor ecx, ecx
06A6509E  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+33
06A650A4  0B C1                         or eax, ecx

#889				JMPCN	$label59	{LNXT:211|212|222}
(-) BOOL
06A650A6  84 C0                         test al, al
06A650A8  90 74 11 90 90 90             je 06A650BCH

#890		
#891				(* THEN *)
#892		
#893					(* Motor_C := False; *)
#894					MOVE		False,Motor_C	{LNXT:212|222|-1}
(*) BOOL
06A650AE  B8 00 00 00 00                mov eax, 00H
06A650B3  84 C0                         test al, al
06A650B5  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#895		
#896		$label59:
#897				(* END_IF *)
#898		
#899		$label25:
#900			(* END_IF *)
#901		
#902		
#903			(* IF Tank_Level >= Max_Level_2 AND Tank_Level < Max_Level_3 *)
#904			LD		Tank_Level	{LNXT:222|-1|-1}
(*) UNDEF
06A650BC  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#905			LT		Max_Level_3	{LNXT:222|-1|-1}
(*) INT
06A650C3  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+178
06A650CA  3B C1                         cmp eax, ecx
06A650CC  0F 9C C0                      setl al
06A650CF  25 FF 00 00 00                and eax, 0FFh

#906			AND(		Tank_Level	{LNXT:222|-1|-1}
(*) BOOL
06A650D4  50                            push eax
06A650D5  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#907			GE		Max_Level_2	{LNXT:222|-1|-1}
(*) INT
06A650DC  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+62
06A650E3  3B C1                         cmp eax, ecx
06A650E5  0F 9D C0                      setge al
06A650E8  25 FF 00 00 00                and eax, 0FFh

#908			)	{LNXT:222|-1|-1}
(*) BOOL
06A650ED  8B C8                         mov ecx, eax
06A650EF  58                            pop eax
06A650F0  23 C1                         and eax, ecx

#909			JMPCN	$label60	{LNXT:222|225|258}
(-) BOOL
06A650F2  84 C0                         test al, al
06A650F4  0F 84 DD 01 00 00             je 06A652D7H

#910		
#911			(* THEN *)
#912		
#913		
#914				(* IF MOTOR_A AND NOT MOTOR_B AND NOT MOTOR_C *)
#915				LD		MOTOR_C	{LNXT:225|-1|-1}
(*) UNDEF
06A650FA  33 C0                         xor eax, eax
06A650FC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#916				NOT	{LNXT:225|-1|-1}
(*) BOOL
06A65102  84 C0                         test al, al
06A65104  0F 94 C0                      sete al

#917				AND(		MOTOR_B	{LNXT:225|-1|-1}
(*) BOOL
06A65107  50                            push eax
06A65108  33 C0                         xor eax, eax
06A6510A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#918				NOT	{LNXT:225|-1|-1}
(*) BOOL
06A65110  84 C0                         test al, al
06A65112  0F 94 C0                      sete al

#919				AND		MOTOR_A	{LNXT:225|-1|-1}
(*) BOOL
06A65115  33 C9                         xor ecx, ecx
06A65117  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %Q1+0
06A6511D  23 C1                         and eax, ecx

#920				)	{LNXT:225|-1|-1}
(*) BOOL
06A6511F  8B C8                         mov ecx, eax
06A65121  58                            pop eax
06A65122  23 C1                         and eax, ecx

#921				JMPCN	$label61	{LNXT:225|226|236}
(-) BOOL
06A65124  84 C0                         test al, al
06A65126  90 74 70 90 90 90             je 06A65199H

#922		
#923				(* THEN *)
#924		
#925		
#926					(* IF Fault_B AND Avto_A *)
#927					LD		Fault_B	{LNXT:226|-1|-1}
(*) UNDEF
06A6512C  33 C0                         xor eax, eax
06A6512E  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31

#928					NOT	{LNXT:226|-1|-1}
(*) BOOL
06A65134  84 C0                         test al, al
06A65136  0F 94 C0                      sete al

#929					AND		Avto_A	{LNXT:226|-1|-1}
(*) BOOL
06A65139  33 C9                         xor ecx, ecx
06A6513B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+30
06A65141  23 C1                         and eax, ecx

#930					JMPCN	$label62	{LNXT:226|227|230}
(-) BOOL
06A65143  84 C0                         test al, al
06A65145  90 74 11 90 90 90             je 06A65159H

#931		
#932					(* THEN *)
#933		
#934						(* Motor_B:= TRUE; *)
#935						MOVE		TRUE,Motor_B	{LNXT:227|230|-1}
(*) BOOL
06A6514B  B8 01 00 00 00                mov eax, 01H
06A65150  84 C0                         test al, al
06A65152  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#936		
#937		$label62:
#938					(* END_IF *)
#939		
#940		
#941					(* IF Fault_C AND Avto_C AND NOT MOTOR_B *)
#942					LD		MOTOR_B	{LNXT:230|-1|-1}
(*) UNDEF
06A65159  33 C0                         xor eax, eax
06A6515B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#943					NOT	{LNXT:230|-1|-1}
(*) BOOL
06A65161  84 C0                         test al, al
06A65163  0F 94 C0                      sete al

#944					AND(		Fault_C	{LNXT:230|-1|-1}
(*) BOOL
06A65166  50                            push eax
06A65167  33 C0                         xor eax, eax
06A65169  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33

#945					NOT	{LNXT:230|-1|-1}
(*) BOOL
06A6516F  84 C0                         test al, al
06A65171  0F 94 C0                      sete al

#946					AND		Avto_C	{LNXT:230|-1|-1}
(*) BOOL
06A65174  33 C9                         xor ecx, ecx
06A65176  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+34
06A6517C  23 C1                         and eax, ecx

#947					)	{LNXT:230|-1|-1}
(*) BOOL
06A6517E  8B C8                         mov ecx, eax
06A65180  58                            pop eax
06A65181  23 C1                         and eax, ecx

#948					JMPCN	$label63	{LNXT:230|231|236}
(-) BOOL
06A65183  84 C0                         test al, al
06A65185  90 74 11 90 90 90             je 06A65199H

#949		
#950					(* THEN *)
#951		
#952						(* Motor_C:= TRUE; *)
#953						MOVE		TRUE,Motor_C	{LNXT:231|236|-1}
(*) BOOL
06A6518B  B8 01 00 00 00                mov eax, 01H
06A65190  84 C0                         test al, al
06A65192  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#954		
#955		$label63:
#956					(* END_IF *)
#957		
#958		$label61:
#959				(* END_IF *)
#960		
#961		
#962				(* IF MOTOR_B AND NOT MOTOR_A AND NOT MOTOR_C *)
#963				LD		MOTOR_C	{LNXT:236|-1|-1}
(*) UNDEF
06A65199  33 C0                         xor eax, eax
06A6519B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#964				NOT	{LNXT:236|-1|-1}
(*) BOOL
06A651A1  84 C0                         test al, al
06A651A3  0F 94 C0                      sete al

#965				AND(		MOTOR_A	{LNXT:236|-1|-1}
(*) BOOL
06A651A6  50                            push eax
06A651A7  33 C0                         xor eax, eax
06A651A9  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#966				NOT	{LNXT:236|-1|-1}
(*) BOOL
06A651AF  84 C0                         test al, al
06A651B1  0F 94 C0                      sete al

#967				AND		MOTOR_B	{LNXT:236|-1|-1}
(*) BOOL
06A651B4  33 C9                         xor ecx, ecx
06A651B6  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %Q1+1
06A651BC  23 C1                         and eax, ecx

#968				)	{LNXT:236|-1|-1}
(*) BOOL
06A651BE  8B C8                         mov ecx, eax
06A651C0  58                            pop eax
06A651C1  23 C1                         and eax, ecx

#969				JMPCN	$label64	{LNXT:236|237|245}
(-) BOOL
06A651C3  84 C0                         test al, al
06A651C5  90 74 70 90 90 90             je 06A65238H

#970		
#971				(* THEN *)
#972		
#973		
#974					(* IF Fault_C AND Avto_B *)
#975					LD		Fault_C	{LNXT:237|-1|-1}
(*) UNDEF
06A651CB  33 C0                         xor eax, eax
06A651CD  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33

#976					NOT	{LNXT:237|-1|-1}
(*) BOOL
06A651D3  84 C0                         test al, al
06A651D5  0F 94 C0                      sete al

#977					AND		Avto_B	{LNXT:237|-1|-1}
(*) BOOL
06A651D8  33 C9                         xor ecx, ecx
06A651DA  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+32
06A651E0  23 C1                         and eax, ecx

#978					JMPCN	$label65	{LNXT:237|238|240}
(-) BOOL
06A651E2  84 C0                         test al, al
06A651E4  90 74 11 90 90 90             je 06A651F8H

#979		
#980					(* THEN *)
#981		
#982						(* Motor_C:= TRUE; *)
#983						MOVE		TRUE,Motor_C	{LNXT:238|240|-1}
(*) BOOL
06A651EA  B8 01 00 00 00                mov eax, 01H
06A651EF  84 C0                         test al, al
06A651F1  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#984		
#985		$label65:
#986					(* END_IF *)
#987		
#988		
#989					(* IF Fault_A AND Avto_A AND NOT MOTOR_C *)
#990					LD		MOTOR_C	{LNXT:240|-1|-1}
(*) UNDEF
06A651F8  33 C0                         xor eax, eax
06A651FA  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#991					NOT	{LNXT:240|-1|-1}
(*) BOOL
06A65200  84 C0                         test al, al
06A65202  0F 94 C0                      sete al

#992					AND(		Fault_A	{LNXT:240|-1|-1}
(*) BOOL
06A65205  50                            push eax
06A65206  33 C0                         xor eax, eax
06A65208  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+23

#993					NOT	{LNXT:240|-1|-1}
(*) BOOL
06A6520E  84 C0                         test al, al
06A65210  0F 94 C0                      sete al

#994					AND		Avto_A	{LNXT:240|-1|-1}
(*) BOOL
06A65213  33 C9                         xor ecx, ecx
06A65215  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+30
06A6521B  23 C1                         and eax, ecx

#995					)	{LNXT:240|-1|-1}
(*) BOOL
06A6521D  8B C8                         mov ecx, eax
06A6521F  58                            pop eax
06A65220  23 C1                         and eax, ecx

#996					JMPCN	$label66	{LNXT:240|241|245}
(-) BOOL
06A65222  84 C0                         test al, al
06A65224  90 74 11 90 90 90             je 06A65238H

#997		
#998					(* THEN *)
#999		
#1000						(* Motor_A:= TRUE; *)
#1001						MOVE		TRUE,Motor_A	{LNXT:241|245|-1}
(*) BOOL
06A6522A  B8 01 00 00 00                mov eax, 01H
06A6522F  84 C0                         test al, al
06A65231  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1002		
#1003		$label66:
#1004					(* END_IF *)
#1005		
#1006		$label64:
#1007				(* END_IF *)
#1008		
#1009		
#1010				(* IF MOTOR_C AND NOT MOTOR_A AND NOT MOTOR_B *)
#1011				LD		MOTOR_B	{LNXT:245|-1|-1}
(*) UNDEF
06A65238  33 C0                         xor eax, eax
06A6523A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#1012				NOT	{LNXT:245|-1|-1}
(*) BOOL
06A65240  84 C0                         test al, al
06A65242  0F 94 C0                      sete al

#1013				AND(		MOTOR_A	{LNXT:245|-1|-1}
(*) BOOL
06A65245  50                            push eax
06A65246  33 C0                         xor eax, eax
06A65248  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#1014				NOT	{LNXT:245|-1|-1}
(*) BOOL
06A6524E  84 C0                         test al, al
06A65250  0F 94 C0                      sete al

#1015				AND		MOTOR_C	{LNXT:245|-1|-1}
(*) BOOL
06A65253  33 C9                         xor ecx, ecx
06A65255  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %Q1+2
06A6525B  23 C1                         and eax, ecx

#1016				)	{LNXT:245|-1|-1}
(*) BOOL
06A6525D  8B C8                         mov ecx, eax
06A6525F  58                            pop eax
06A65260  23 C1                         and eax, ecx

#1017				JMPCN	$label67	{LNXT:245|246|258}
(-) BOOL
06A65262  84 C0                         test al, al
06A65264  90 74 70 90 90 90             je 06A652D7H

#1018		
#1019				(* THEN *)
#1020		
#1021		
#1022					(* IF Fault_A AND Avto_C *)
#1023					LD		Fault_A	{LNXT:246|-1|-1}
(*) UNDEF
06A6526A  33 C0                         xor eax, eax
06A6526C  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+23

#1024					NOT	{LNXT:246|-1|-1}
(*) BOOL
06A65272  84 C0                         test al, al
06A65274  0F 94 C0                      sete al

#1025					AND		Avto_C	{LNXT:246|-1|-1}
(*) BOOL
06A65277  33 C9                         xor ecx, ecx
06A65279  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+34
06A6527F  23 C1                         and eax, ecx

#1026					JMPCN	$label68	{LNXT:246|247|249}
(-) BOOL
06A65281  84 C0                         test al, al
06A65283  90 74 11 90 90 90             je 06A65297H

#1027		
#1028					(* THEN *)
#1029		
#1030						(* Motor_A:= TRUE; *)
#1031						MOVE		TRUE,Motor_A	{LNXT:247|249|-1}
(*) BOOL
06A65289  B8 01 00 00 00                mov eax, 01H
06A6528E  84 C0                         test al, al
06A65290  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1032		
#1033		$label68:
#1034					(* END_IF *)
#1035		
#1036		
#1037					(* IF Fault_B AND Avto_B AND NOT MOTOR_A *)
#1038					LD		MOTOR_A	{LNXT:249|-1|-1}
(*) UNDEF
06A65297  33 C0                         xor eax, eax
06A65299  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#1039					NOT	{LNXT:249|-1|-1}
(*) BOOL
06A6529F  84 C0                         test al, al
06A652A1  0F 94 C0                      sete al

#1040					AND(		Fault_B	{LNXT:249|-1|-1}
(*) BOOL
06A652A4  50                            push eax
06A652A5  33 C0                         xor eax, eax
06A652A7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31

#1041					NOT	{LNXT:249|-1|-1}
(*) BOOL
06A652AD  84 C0                         test al, al
06A652AF  0F 94 C0                      sete al

#1042					AND		Avto_B	{LNXT:249|-1|-1}
(*) BOOL
06A652B2  33 C9                         xor ecx, ecx
06A652B4  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+32
06A652BA  23 C1                         and eax, ecx

#1043					)	{LNXT:249|-1|-1}
(*) BOOL
06A652BC  8B C8                         mov ecx, eax
06A652BE  58                            pop eax
06A652BF  23 C1                         and eax, ecx

#1044					JMPCN	$label69	{LNXT:249|250|258}
(-) BOOL
06A652C1  84 C0                         test al, al
06A652C3  90 74 11 90 90 90             je 06A652D7H

#1045		
#1046					(* THEN *)
#1047		
#1048						(* Motor_B:= TRUE; *)
#1049						MOVE		TRUE,Motor_B	{LNXT:250|258|-1}
(*) BOOL
06A652C9  B8 01 00 00 00                mov eax, 01H
06A652CE  84 C0                         test al, al
06A652D0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#1050		
#1051		$label69:
#1052					(* END_IF *)
#1053		
#1054		$label67:
#1055				(* END_IF *)
#1056		
#1057		$label60:
#1058			(* END_IF *)
#1059		
#1060		
#1061			(* IF Tank_Level <= Max_Level_1 and Motor_A and Motor_B and Motor_C *)
#1062			LD		Tank_Level	{LNXT:258|-1|-1}
(*) UNDEF
06A652D7  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#1063			LE		Max_Level_1	{LNXT:258|-1|-1}
(*) INT
06A652DE  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A652E5  3B C1                         cmp eax, ecx
06A652E7  0F 9E C0                      setle al
06A652EA  25 FF 00 00 00                and eax, 0FFh

#1064			AND		Motor_A	{LNXT:258|-1|-1}
(*) BOOL
06A652EF  33 C9                         xor ecx, ecx
06A652F1  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %Q1+0
06A652F7  23 C1                         and eax, ecx

#1065			AND		Motor_B	{LNXT:258|-1|-1}
(*) BOOL
06A652F9  33 C9                         xor ecx, ecx
06A652FB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %Q1+1
06A65301  23 C1                         and eax, ecx

#1066			AND		Motor_C	{LNXT:258|-1|-1}
(*) BOOL
06A65303  33 C9                         xor ecx, ecx
06A65305  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %Q1+2
06A6530B  23 C1                         and eax, ecx

#1067			JMPCN	$label70	{LNXT:258|259|265}
(-) BOOL
06A6530D  84 C0                         test al, al
06A6530F  90 74 11 90 90 90             je 06A65323H

#1068		
#1069			(* THEN *)
#1070		
#1071				(* Motor_A := False; *)
#1072				MOVE		False,Motor_A	{LNXT:259|265|-1}
(*) BOOL
06A65315  B8 00 00 00 00                mov eax, 00H
06A6531A  84 C0                         test al, al
06A6531C  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1073		
#1074		$label70:
#1075			(* END_IF *)
#1076		
#1077		
#1078			(* IF Tank_Level > Max_Level_3 *)
#1079			LD		Tank_Level	{LNXT:265|-1|-1}
(*) UNDEF
06A65323  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#1080			GT		Max_Level_3	{LNXT:265|-1|-1}
(*) INT
06A6532A  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+178
06A65331  3B C1                         cmp eax, ecx
06A65333  0F 9F C0                      setg al
06A65336  25 FF 00 00 00                and eax, 0FFh

#1081			JMPCN	$label71	{LNXT:265|266|293}
(-) BOOL
06A6533B  84 C0                         test al, al
06A6533D  0F 84 0E 01 00 00             je 06A65451H

#1082		
#1083			(* THEN *)
#1084		
#1085		
#1086				(* IF Fault_A AND Avto_A *)
#1087				LD		Fault_A	{LNXT:266|-1|-1}
(*) UNDEF
06A65343  33 C0                         xor eax, eax
06A65345  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+23

#1088				NOT	{LNXT:266|-1|-1}
(*) BOOL
06A6534B  84 C0                         test al, al
06A6534D  0F 94 C0                      sete al

#1089				AND		Avto_A	{LNXT:266|-1|-1}
(*) BOOL
06A65350  33 C9                         xor ecx, ecx
06A65352  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+30
06A65358  23 C1                         and eax, ecx

#1090				JMPCN	$label72	{LNXT:266|267|270}
(-) BOOL
06A6535A  84 C0                         test al, al
06A6535C  90 74 11 90 90 90             je 06A65370H

#1091		
#1092				(* THEN *)
#1093		
#1094					(* Motor_A := TRUE; *)
#1095					MOVE		TRUE,Motor_A	{LNXT:267|270|-1}
(*) BOOL
06A65362  B8 01 00 00 00                mov eax, 01H
06A65367  84 C0                         test al, al
06A65369  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1096		
#1097		$label72:
#1098				(* END_IF *)
#1099		
#1100		
#1101				(* IF Fault_B AND Avto_B *)
#1102				LD		Fault_B	{LNXT:270|-1|-1}
(*) UNDEF
06A65370  33 C0                         xor eax, eax
06A65372  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+31

#1103				NOT	{LNXT:270|-1|-1}
(*) BOOL
06A65378  84 C0                         test al, al
06A6537A  0F 94 C0                      sete al

#1104				AND		Avto_B	{LNXT:270|-1|-1}
(*) BOOL
06A6537D  33 C9                         xor ecx, ecx
06A6537F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+32
06A65385  23 C1                         and eax, ecx

#1105				JMPCN	$label73	{LNXT:270|271|274}
(-) BOOL
06A65387  84 C0                         test al, al
06A65389  90 74 11 90 90 90             je 06A6539DH

#1106		
#1107				(* THEN *)
#1108		
#1109					(* Motor_B := TRUE; *)
#1110					MOVE		TRUE,Motor_B	{LNXT:271|274|-1}
(*) BOOL
06A6538F  B8 01 00 00 00                mov eax, 01H
06A65394  84 C0                         test al, al
06A65396  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#1111		
#1112		$label73:
#1113				(* END_IF *)
#1114		
#1115		
#1116				(* IF Fault_C AND Avto_C *)
#1117				LD		Fault_C	{LNXT:274|-1|-1}
(*) UNDEF
06A6539D  33 C0                         xor eax, eax
06A6539F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+33

#1118				NOT	{LNXT:274|-1|-1}
(*) BOOL
06A653A5  84 C0                         test al, al
06A653A7  0F 94 C0                      sete al

#1119				AND		Avto_C	{LNXT:274|-1|-1}
(*) BOOL
06A653AA  33 C9                         xor ecx, ecx
06A653AC  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+34
06A653B2  23 C1                         and eax, ecx

#1120				JMPCN	$label74	{LNXT:274|275|278}
(-) BOOL
06A653B4  84 C0                         test al, al
06A653B6  90 74 11 90 90 90             je 06A653CAH

#1121		
#1122				(* THEN *)
#1123		
#1124					(* Motor_C := TRUE; *)
#1125					MOVE		TRUE,Motor_C	{LNXT:275|278|-1}
(*) BOOL
06A653BC  B8 01 00 00 00                mov eax, 01H
06A653C1  84 C0                         test al, al
06A653C3  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#1126		
#1127		$label74:
#1128				(* END_IF *)
#1129		
#1130		
#1131				(* IF Fault_A or  NOT Avto_A *)
#1132				LD		Avto_A	{LNXT:278|-1|-1}
(*) UNDEF
06A653CA  33 C0                         xor eax, eax
06A653CC  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30

#1133				NOT	{LNXT:278|-1|-1}
(*) BOOL
06A653D2  84 C0                         test al, al
06A653D4  0F 94 C0                      sete al

#1134				OR		Fault_A	{LNXT:278|-1|-1}
(*) BOOL
06A653D7  33 C9                         xor ecx, ecx
06A653D9  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+23
06A653DF  0B C1                         or eax, ecx

#1135				JMPCN	$label75	{LNXT:278|279|281}
(-) BOOL
06A653E1  84 C0                         test al, al
06A653E3  90 74 11 90 90 90             je 06A653F7H

#1136		
#1137				(* THEN *)
#1138		
#1139					(* Motor_A := False; *)
#1140					MOVE		False,Motor_A	{LNXT:279|281|-1}
(*) BOOL
06A653E9  B8 00 00 00 00                mov eax, 00H
06A653EE  84 C0                         test al, al
06A653F0  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1141		
#1142		$label75:
#1143				(* END_IF *)
#1144		
#1145		
#1146				(* IF Fault_B or  NOT Avto_B *)
#1147				LD		Avto_B	{LNXT:281|-1|-1}
(*) UNDEF
06A653F7  33 C0                         xor eax, eax
06A653F9  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32

#1148				NOT	{LNXT:281|-1|-1}
(*) BOOL
06A653FF  84 C0                         test al, al
06A65401  0F 94 C0                      sete al

#1149				OR		Fault_B	{LNXT:281|-1|-1}
(*) BOOL
06A65404  33 C9                         xor ecx, ecx
06A65406  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+31
06A6540C  0B C1                         or eax, ecx

#1150				JMPCN	$label76	{LNXT:281|282|284}
(-) BOOL
06A6540E  84 C0                         test al, al
06A65410  90 74 11 90 90 90             je 06A65424H

#1151		
#1152				(* THEN *)
#1153		
#1154					(* Motor_B := False; *)
#1155					MOVE		False,Motor_B	{LNXT:282|284|-1}
(*) BOOL
06A65416  B8 00 00 00 00                mov eax, 00H
06A6541B  84 C0                         test al, al
06A6541D  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#1156		
#1157		$label76:
#1158				(* END_IF *)
#1159		
#1160		
#1161				(* IF Fault_C or  NOT Avto_C *)
#1162				LD		Avto_C	{LNXT:284|-1|-1}
(*) UNDEF
06A65424  33 C0                         xor eax, eax
06A65426  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34

#1163				NOT	{LNXT:284|-1|-1}
(*) BOOL
06A6542C  84 C0                         test al, al
06A6542E  0F 94 C0                      sete al

#1164				OR		Fault_C	{LNXT:284|-1|-1}
(*) BOOL
06A65431  33 C9                         xor ecx, ecx
06A65433  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; $$DATA$$+33
06A65439  0B C1                         or eax, ecx

#1165				JMPCN	$label77	{LNXT:284|285|293}
(-) BOOL
06A6543B  84 C0                         test al, al
06A6543D  90 74 11 90 90 90             je 06A65451H

#1166		
#1167				(* THEN *)
#1168		
#1169					(* Motor_C := False; *)
#1170					MOVE		False,Motor_C	{LNXT:285|293|-1}
(*) BOOL
06A65443  B8 00 00 00 00                mov eax, 00H
06A65448  84 C0                         test al, al
06A6544A  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#1171		
#1172		$label77:
#1173				(* END_IF *)
#1174		
#1175		$label71:
#1176			(* END_IF *)
#1177		
#1178		
#1179			(* IF Tank_Level <= Min_Level *)
#1180			LD		Tank_Level	{LNXT:293|-1|-1}
(*) UNDEF
06A65451  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#1181			LE		Min_Level	{LNXT:293|-1|-1}
(*) INT
06A65458  0F BF 0D CC CC CC CC          movsx ecx, word ptr [CCCCCCCCH] ; $$DATA$$+180
06A6545F  3B C1                         cmp eax, ecx
06A65461  0F 9E C0                      setle al
06A65464  25 FF 00 00 00                and eax, 0FFh

#1182			JMPCN	$label78	{LNXT:293|294|302}
(-) BOOL
06A65469  84 C0                         test al, al
06A6546B  90 74 2D 90 90 90             je 06A6549BH

#1183		
#1184			(* THEN *)
#1185		
#1186				(* Motor_A := False; *)
#1187				MOVE		False,Motor_A	{LNXT:294|295|-1}
(*) BOOL
06A65471  B8 00 00 00 00                mov eax, 00H
06A65476  84 C0                         test al, al
06A65478  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1188		
#1189				(* Motor_B := False; *)
#1190				MOVE		False,Motor_B	{LNXT:295|296|-1}
(*) BOOL
06A6547F  B8 00 00 00 00                mov eax, 00H
06A65484  84 C0                         test al, al
06A65486  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#1191		
#1192				(* Motor_C := False; *)
#1193				MOVE		False,Motor_C	{LNXT:296|302|-1}
(*) BOOL
06A6548D  B8 00 00 00 00                mov eax, 00H
06A65492  84 C0                         test al, al
06A65494  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#1194		
#1195		$label78:
#1196			(* END_IF *)
#1197		
#1198		
#1199			(* IF Avto_A *)
#1200			LD		Avto_A	{LNXT:302|-1|-1}
(*) UNDEF
06A6549B  33 C0                         xor eax, eax
06A6549D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30

#1201			NOT	{LNXT:302|-1|-1}
(*) BOOL
06A654A3  84 C0                         test al, al
06A654A5  0F 94 C0                      sete al

#1202			JMPCN	$label79	{LNXT:302|303|306}
(-) BOOL
06A654A8  84 C0                         test al, al
06A654AA  90 74 11 90 90 90             je 06A654BEH

#1203		
#1204			(* THEN *)
#1205		
#1206				(* Motor_A := False; *)
#1207				MOVE		False,Motor_A	{LNXT:303|306|-1}
(*) BOOL
06A654B0  B8 00 00 00 00                mov eax, 00H
06A654B5  84 C0                         test al, al
06A654B7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1208		
#1209		$label79:
#1210			(* END_IF *)
#1211		
#1212		
#1213			(* IF Avto_B *)
#1214			LD		Avto_B	{LNXT:306|-1|-1}
(*) UNDEF
06A654BE  33 C0                         xor eax, eax
06A654C0  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32

#1215			NOT	{LNXT:306|-1|-1}
(*) BOOL
06A654C6  84 C0                         test al, al
06A654C8  0F 94 C0                      sete al

#1216			JMPCN	$label80	{LNXT:306|307|310}
(-) BOOL
06A654CB  84 C0                         test al, al
06A654CD  90 74 11 90 90 90             je 06A654E1H

#1217		
#1218			(* THEN *)
#1219		
#1220				(* Motor_B := False; *)
#1221				MOVE		False,Motor_B	{LNXT:307|310|-1}
(*) BOOL
06A654D3  B8 00 00 00 00                mov eax, 00H
06A654D8  84 C0                         test al, al
06A654DA  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#1222		
#1223		$label80:
#1224			(* END_IF *)
#1225		
#1226		
#1227			(* IF Avto_C *)
#1228			LD		Avto_C	{LNXT:310|-1|-1}
(*) UNDEF
06A654E1  33 C0                         xor eax, eax
06A654E3  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34

#1229			NOT	{LNXT:310|-1|-1}
(*) BOOL
06A654E9  84 C0                         test al, al
06A654EB  0F 94 C0                      sete al

#1230			JMPCN	$label81	{LNXT:310|311|322}
(-) BOOL
06A654EE  84 C0                         test al, al
06A654F0  90 74 11 90 90 90             je 06A65504H

#1231		
#1232			(* THEN *)
#1233		
#1234				(* Motor_C := False; *)
#1235				MOVE		False,Motor_C	{LNXT:311|322|-1}
(*) BOOL
06A654F6  B8 00 00 00 00                mov eax, 00H
06A654FB  84 C0                         test al, al
06A654FD  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#1236		
#1237		$label81:
#1238			(* END_IF *)
#1239		
#1240		
#1241			(* IF Motor_A *)
#1242			LD		Motor_A	{LNXT:322|-1|-1}
(*) UNDEF
06A65504  33 C0                         xor eax, eax
06A65506  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#1243			JMPCN	$label82	{LNXT:322|323|332}
(-) BOOL
06A6550C  84 C0                         test al, al
06A6550E  90 74 6B 90 90 90             je 06A6557CH

#1244		
#1245			(* THEN *)
#1246		
#1247				(* ErrorTimer_A *)
#1248				MOVE		TRUE,ErrorTimer_A.IN	{LNXT:323|-1|-1}
(*) BOOL
06A65514  B8 01 00 00 00                mov eax, 01H
06A65519  84 C0                         test al, al
06A6551B  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+186

#1249				MOVE		TM_WAIT,ErrorTimer_A.PT	{LNXT:323|-1|-1}
(*) BOOL
06A65522  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
06A65529  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+187

#1250				CAL		ErrorTimer_A	{LNXT:323|324|-1}
(*) INT
06A6552F  50                            push eax
06A65530  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+182
06A65535  E8 B6 ED FF FF                call 06A642F0H ; $$CODE$$+17136
06A6553A  58                            pop eax

#1251		
#1252		
#1253				(* IF ErrorTimer_A.Q *)
#1254				LD		ErrorTimer_A.Q	{LNXT:324|-1|-1}
(*) UNDEF
06A6553B  33 C0                         xor eax, eax
06A6553D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+191

#1255				JMPCN	$label84	{LNXT:324|325|335}
(-) BOOL
06A65543  84 C0                         test al, al
06A65545  90 74 2F 90 90 90             je 06A65577H

#1256		
#1257				(* THEN *)
#1258		
#1259		
#1260					(* IF ALM_A *)
#1261					LD		ALM_A	{LNXT:325|-1|-1}
(*) UNDEF
06A6554B  33 C0                         xor eax, eax
06A6554D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+133

#1262					JMPCN	$label85	{LNXT:325|326|335}
(-) BOOL
06A65553  84 C0                         test al, al
06A65555  90 74 1F 90 90 90             je 06A65577H

#1263		
#1264					(* THEN *)
#1265		
#1266						(* Fault_A := TRUE; *)
#1267						MOVE		TRUE,Fault_A	{LNXT:326|328|-1}
(*) BOOL
06A6555B  B8 01 00 00 00                mov eax, 01H
06A65560  84 C0                         test al, al
06A65562  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+23

#1268		
#1269						(* Motor_A := FALSE; *)
#1270						MOVE		FALSE,Motor_A	{LNXT:328|335|-1}
(*) BOOL
06A65569  B8 00 00 00 00                mov eax, 00H
06A6556E  84 C0                         test al, al
06A65570  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+0

#1271		
#1272		$label85:
#1273					(* END_IF *)
#1274		
#1275		$label84:
#1276				(* END_IF *)
#1277				JMP		$label83	{LNXT:322|323|332}
(-) BOOL
06A65577  EB 1D 90 90 90                jmp 06A65596H

#1278		$label82:
#1279		
#1280			(* ELSE *)
#1281		
#1282				(* ErrorTimer_A *)
#1283				MOVE		FALSE,ErrorTimer_A.IN	{LNXT:332|-1|-1}
(*) BOOL
06A6557C  B8 00 00 00 00                mov eax, 00H
06A65581  84 C0                         test al, al
06A65583  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+186

#1284				CAL		ErrorTimer_A	{LNXT:332|335|-1}
(*) BOOL
06A6558A  50                            push eax
06A6558B  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+182
06A65590  E8 5B ED FF FF                call 06A642F0H ; $$CODE$$+17136
06A65595  58                            pop eax

#1285		
#1286		$label83:
#1287			(* END_IF *)
#1288		
#1289		
#1290			(* IF Motor_B *)
#1291			LD		Motor_B	{LNXT:335|-1|-1}
(*) UNDEF
06A65596  33 C0                         xor eax, eax
06A65598  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#1292			JMPCN	$label86	{LNXT:335|336|345}
(-) BOOL
06A6559E  84 C0                         test al, al
06A655A0  90 74 6B 90 90 90             je 06A6560EH

#1293		
#1294			(* THEN *)
#1295		
#1296				(* ErrorTimer_B *)
#1297				MOVE		TRUE,ErrorTimer_B.IN	{LNXT:336|-1|-1}
(*) BOOL
06A655A6  B8 01 00 00 00                mov eax, 01H
06A655AB  84 C0                         test al, al
06A655AD  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+208

#1298				MOVE		TM_WAIT,ErrorTimer_B.PT	{LNXT:336|-1|-1}
(*) BOOL
06A655B4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
06A655BB  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+209

#1299				CAL		ErrorTimer_B	{LNXT:336|337|-1}
(*) INT
06A655C1  50                            push eax
06A655C2  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+204
06A655C7  E8 24 ED FF FF                call 06A642F0H ; $$CODE$$+17136
06A655CC  58                            pop eax

#1300		
#1301		
#1302				(* IF ErrorTimer_B.Q *)
#1303				LD		ErrorTimer_B.Q	{LNXT:337|-1|-1}
(*) UNDEF
06A655CD  33 C0                         xor eax, eax
06A655CF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+213

#1304				JMPCN	$label88	{LNXT:337|338|349}
(-) BOOL
06A655D5  84 C0                         test al, al
06A655D7  90 74 2F 90 90 90             je 06A65609H

#1305		
#1306				(* THEN *)
#1307		
#1308		
#1309					(* IF ALM_B *)
#1310					LD		ALM_B	{LNXT:338|-1|-1}
(*) UNDEF
06A655DD  33 C0                         xor eax, eax
06A655DF  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+226

#1311					JMPCN	$label89	{LNXT:338|339|349}
(-) BOOL
06A655E5  84 C0                         test al, al
06A655E7  90 74 1F 90 90 90             je 06A65609H

#1312		
#1313					(* THEN *)
#1314		
#1315						(* Fault_B := TRUE; *)
#1316						MOVE		TRUE,Fault_B	{LNXT:339|341|-1}
(*) BOOL
06A655ED  B8 01 00 00 00                mov eax, 01H
06A655F2  84 C0                         test al, al
06A655F4  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+31

#1317		
#1318						(* Motor_B := FALSE; *)
#1319						MOVE		FALSE,Motor_B	{LNXT:341|349|-1}
(*) BOOL
06A655FB  B8 00 00 00 00                mov eax, 00H
06A65600  84 C0                         test al, al
06A65602  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+1

#1320		
#1321		$label89:
#1322					(* END_IF *)
#1323		
#1324		$label88:
#1325				(* END_IF *)
#1326				JMP		$label87	{LNXT:335|336|345}
(-) BOOL
06A65609  EB 1D 90 90 90                jmp 06A65628H

#1327		$label86:
#1328		
#1329			(* ELSE *)
#1330		
#1331				(* ErrorTimer_B *)
#1332				MOVE		FALSE,ErrorTimer_B.IN	{LNXT:345|-1|-1}
(*) BOOL
06A6560E  B8 00 00 00 00                mov eax, 00H
06A65613  84 C0                         test al, al
06A65615  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+208

#1333				CAL		ErrorTimer_B	{LNXT:345|349|-1}
(*) BOOL
06A6561C  50                            push eax
06A6561D  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+204
06A65622  E8 C9 EC FF FF                call 06A642F0H ; $$CODE$$+17136
06A65627  58                            pop eax

#1334		
#1335		$label87:
#1336			(* END_IF *)
#1337		
#1338		
#1339			(* IF Motor_C *)
#1340			LD		Motor_C	{LNXT:349|-1|-1}
(*) UNDEF
06A65628  33 C0                         xor eax, eax
06A6562A  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#1341			JMPCN	$label90	{LNXT:349|350|359}
(-) BOOL
06A65630  84 C0                         test al, al
06A65632  90 74 6B 90 90 90             je 06A656A0H

#1342		
#1343			(* THEN *)
#1344		
#1345				(* ErrorTimer_C *)
#1346				MOVE		TRUE,ErrorTimer_C.IN	{LNXT:350|-1|-1}
(*) BOOL
06A65638  B8 01 00 00 00                mov eax, 01H
06A6563D  84 C0                         test al, al
06A6563F  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+232

#1347				MOVE		TM_WAIT,ErrorTimer_C.PT	{LNXT:350|-1|-1}
(*) BOOL
06A65646  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+18
06A6564D  89 05 CC CC CC CC             mov [CCCCCCCCH], eax ; $$DATA$$+233

#1348				CAL		ErrorTimer_C	{LNXT:350|351|-1}
(*) INT
06A65653  50                            push eax
06A65654  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+228
06A65659  E8 92 EC FF FF                call 06A642F0H ; $$CODE$$+17136
06A6565E  58                            pop eax

#1349		
#1350		
#1351				(* IF ErrorTimer_C.Q *)
#1352				LD		ErrorTimer_C.Q	{LNXT:351|-1|-1}
(*) UNDEF
06A6565F  33 C0                         xor eax, eax
06A65661  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+237

#1353				JMPCN	$label92	{LNXT:351|352|364}
(-) BOOL
06A65667  84 C0                         test al, al
06A65669  90 74 2F 90 90 90             je 06A6569BH

#1354		
#1355				(* THEN *)
#1356		
#1357		
#1358					(* IF ALM_C *)
#1359					LD		ALM_C	{LNXT:352|-1|-1}
(*) UNDEF
06A6566F  33 C0                         xor eax, eax
06A65671  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+227

#1360					JMPCN	$label93	{LNXT:352|353|364}
(-) BOOL
06A65677  84 C0                         test al, al
06A65679  90 74 1F 90 90 90             je 06A6569BH

#1361		
#1362					(* THEN *)
#1363		
#1364						(* Fault_C := TRUE; *)
#1365						MOVE		TRUE,Fault_C	{LNXT:353|355|-1}
(*) BOOL
06A6567F  B8 01 00 00 00                mov eax, 01H
06A65684  84 C0                         test al, al
06A65686  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+33

#1366		
#1367						(* Motor_C := FALSE; *)
#1368						MOVE		FALSE,Motor_C	{LNXT:355|364|-1}
(*) BOOL
06A6568D  B8 00 00 00 00                mov eax, 00H
06A65692  84 C0                         test al, al
06A65694  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; %Q1+2

#1369		
#1370		$label93:
#1371					(* END_IF *)
#1372		
#1373		$label92:
#1374				(* END_IF *)
#1375				JMP		$label91	{LNXT:349|350|359}
(-) BOOL
06A6569B  EB 1D 90 90 90                jmp 06A656BAH

#1376		$label90:
#1377		
#1378			(* ELSE *)
#1379		
#1380				(* ErrorTimer_C *)
#1381				MOVE		FALSE,ErrorTimer_C.IN	{LNXT:359|-1|-1}
(*) BOOL
06A656A0  B8 00 00 00 00                mov eax, 00H
06A656A5  84 C0                         test al, al
06A656A7  0F 95 05 CC CC CC CC          setne [CCCCCCCCH] ; $$DATA$$+232

#1382				CAL		ErrorTimer_C	{LNXT:359|364|-1}
(*) BOOL
06A656AE  50                            push eax
06A656AF  BB CC CC CC CC                mov ebx, CCCCCCCCH ; $$DATA$$+228
06A656B4  E8 37 EC FF FF                call 06A642F0H ; $$CODE$$+17136
06A656B9  58                            pop eax

#1383		
#1384		$label91:
#1385			(* END_IF *)
#1386		
#1387			(* level_min := Min_Level; *)
#1388			MOVE		Min_Level,level_min	{LNXT:364|365|-1}
(*) BOOL
06A656BA  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+180
06A656C1  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+4

#1389		
#1390			(* Level_1 := Max_Level_1; *)
#1391			MOVE		Max_Level_1,Level_1	{LNXT:365|366|-1}
(*) INT
06A656C8  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+26
06A656CF  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+6

#1392		
#1393			(* Level_2 := Max_Level_2; *)
#1394			MOVE		Max_Level_2,Level_2	{LNXT:366|367|-1}
(*) INT
06A656D6  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+62
06A656DD  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+8

#1395		
#1396			(* Level_3 := Max_Level_3; *)
#1397			MOVE		Max_Level_3,Level_3	{LNXT:367|370|-1}
(*) INT
06A656E4  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+178
06A656EB  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+10

#1398		
#1399			(* Alarms.5 := Avto_A; *)
#1400			MOVE		Avto_A,Alarms.5	{LNXT:370|371|-1}
(*) INT
06A656F2  33 C0                         xor eax, eax
06A656F4  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+30
06A656FA  84 C0                         test al, al
06A656FC  90 75 11 90 90 90             jne 00000014H@
06A65702  66 0F BA 35 CC CC CC CC 05    btr word ptr [CCCCCCCCH], 5 ; %M110+14
06A6570B  EB 0C 90 90 90                jmp 0000000EH@
06A65710  66 0F BA 2D CC CC CC CC 05    bts word ptr [CCCCCCCCH], 5 ; %M110+14

#1401		
#1402			(* Alarms.6 := Avto_B; *)
#1403			MOVE		Avto_B,Alarms.6	{LNXT:371|372|-1}
(*) BOOL
06A65719  33 C0                         xor eax, eax
06A6571B  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+32
06A65721  84 C0                         test al, al
06A65723  90 75 11 90 90 90             jne 00000014H@
06A65729  66 0F BA 35 CC CC CC CC 06    btr word ptr [CCCCCCCCH], 6 ; %M110+14
06A65732  EB 0C 90 90 90                jmp 0000000EH@
06A65737  66 0F BA 2D CC CC CC CC 06    bts word ptr [CCCCCCCCH], 6 ; %M110+14

#1404		
#1405			(* Alarms.7 := Avto_C; *)
#1406			MOVE		Avto_C,Alarms.7	{LNXT:372|375|-1}
(*) BOOL
06A65740  33 C0                         xor eax, eax
06A65742  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+34
06A65748  84 C0                         test al, al
06A6574A  90 75 11 90 90 90             jne 00000014H@
06A65750  66 0F BA 35 CC CC CC CC 07    btr word ptr [CCCCCCCCH], 7 ; %M110+14
06A65759  EB 0C 90 90 90                jmp 0000000EH@
06A6575E  66 0F BA 2D CC CC CC CC 07    bts word ptr [CCCCCCCCH], 7 ; %M110+14

#1407		
#1408			(* Alarms.8 := ALM_A; *)
#1409			MOVE		ALM_A,Alarms.8	{LNXT:375|376|-1}
(*) BOOL
06A65767  33 C0                         xor eax, eax
06A65769  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+133
06A6576F  84 C0                         test al, al
06A65771  90 75 11 90 90 90             jne 00000014H@
06A65777  66 0F BA 35 CC CC CC CC 08    btr word ptr [CCCCCCCCH], 8 ; %M110+14
06A65780  EB 0C 90 90 90                jmp 0000000EH@
06A65785  66 0F BA 2D CC CC CC CC 08    bts word ptr [CCCCCCCCH], 8 ; %M110+14

#1410		
#1411			(* Alarms.9 := ALM_B; *)
#1412			MOVE		ALM_B,Alarms.9	{LNXT:376|377|-1}
(*) BOOL
06A6578E  33 C0                         xor eax, eax
06A65790  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+226
06A65796  84 C0                         test al, al
06A65798  90 75 11 90 90 90             jne 00000014H@
06A6579E  66 0F BA 35 CC CC CC CC 09    btr word ptr [CCCCCCCCH], 9 ; %M110+14
06A657A7  EB 0C 90 90 90                jmp 0000000EH@
06A657AC  66 0F BA 2D CC CC CC CC 09    bts word ptr [CCCCCCCCH], 9 ; %M110+14

#1413		
#1414			(* Alarms.10 := ALM_C; *)
#1415			MOVE		ALM_C,Alarms.10	{LNXT:377|4|-1}
(*) BOOL
06A657B5  33 C0                         xor eax, eax
06A657B7  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+227
06A657BD  84 C0                         test al, al
06A657BF  90 75 11 90 90 90             jne 00000014H@
06A657C5  66 0F BA 35 CC CC CC CC 0A    btr word ptr [CCCCCCCCH], 10 ; %M110+14
06A657CE  EB 0C 90 90 90                jmp 0000000EH@
06A657D3  66 0F BA 2D CC CC CC CC 0A    bts word ptr [CCCCCCCCH], 10 ; %M110+14

END_PROGRAM
**************************************************
	List program: Register
**************************************************

PROGRAM Register

END_PROGRAM

#0		{SRC:Register}
#1		(*$WAITSWITCH$*)
#2		
#3			(* level_tank := to_int(to_real(Tank_Level) / 10); *)
#4			LDP0		Tank_Level	{LNXT:3|6|-1}
(*) UDINT
#5			to_real	{LNXT:3|6|-1}
(*) UDINT
06A657DC  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24
06A657E3  50                            push eax
06A657E4  DB 04 24                      fild dword ptr [esp]
06A657E7  58                            pop eax

#6			DIV		10	{LNXT:3|6|-1}
(*) REAL
06A657E8  68 0A 00 00 00                push 10
06A657ED  DA 34 24                      fidiv [esp]
06A657F0  81 C4 04 00 00 00             add esp, 4

#7			to_int	{LNXT:3|6|-1}
(*) REAL
06A657F6  81 EC 08 00 00 00             sub esp, 8
06A657FC  DF 3C 24                      fistp qword ptr [esp]
06A657FF  58                            pop eax
06A65800  81 C4 04 00 00 00             add esp, 4

#8			ST		level_tank	{LNXT:3|6|-1}
(*) INT
06A65806  66 89 05 CC CC CC CC          mov [CCCCCCCCH], ax ; %M110+2

#9		
#10			(* Alarms.0 := di_sensor_Min; *)
#11			MOVE		di_sensor_Min,Alarms.0	{LNXT:6|7|-1}
(*) INT
06A6580D  33 C0                         xor eax, eax
06A6580F  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+260
06A65815  84 C0                         test al, al
06A65817  90 75 11 90 90 90             jne 00000014H@
06A6581D  66 0F BA 35 CC CC CC CC 00    btr word ptr [CCCCCCCCH], 0 ; %M110+14
06A65826  EB 0C 90 90 90                jmp 0000000EH@
06A6582B  66 0F BA 2D CC CC CC CC 00    bts word ptr [CCCCCCCCH], 0 ; %M110+14

#12		
#13			(* Alarms.1 := di_sensor_Max; *)
#14			MOVE		di_sensor_Max,Alarms.1	{LNXT:7|8|-1}
(*) BOOL
06A65834  33 C0                         xor eax, eax
06A65836  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+261
06A6583C  84 C0                         test al, al
06A6583E  90 75 11 90 90 90             jne 00000014H@
06A65844  66 0F BA 35 CC CC CC CC 01    btr word ptr [CCCCCCCCH], 1 ; %M110+14
06A6584D  EB 0C 90 90 90                jmp 0000000EH@
06A65852  66 0F BA 2D CC CC CC CC 01    bts word ptr [CCCCCCCCH], 1 ; %M110+14

#15		
#16			(* Alarms.2 := di_flooding; *)
#17			MOVE		di_flooding,Alarms.2	{LNXT:8|9|-1}
(*) BOOL
06A6585B  33 C0                         xor eax, eax
06A6585D  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+262
06A65863  84 C0                         test al, al
06A65865  90 75 11 90 90 90             jne 00000014H@
06A6586B  66 0F BA 35 CC CC CC CC 02    btr word ptr [CCCCCCCCH], 2 ; %M110+14
06A65874  EB 0C 90 90 90                jmp 0000000EH@
06A65879  66 0F BA 2D CC CC CC CC 02    bts word ptr [CCCCCCCCH], 2 ; %M110+14

#18		
#19			(* Alarms.3 := di_door; *)
#20			MOVE		di_door,Alarms.3	{LNXT:9|10|-1}
(*) BOOL
06A65882  33 C0                         xor eax, eax
06A65884  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+263
06A6588A  84 C0                         test al, al
06A6588C  90 75 11 90 90 90             jne 00000014H@
06A65892  66 0F BA 35 CC CC CC CC 03    btr word ptr [CCCCCCCCH], 3 ; %M110+14
06A6589B  EB 0C 90 90 90                jmp 0000000EH@
06A658A0  66 0F BA 2D CC CC CC CC 03    bts word ptr [CCCCCCCCH], 3 ; %M110+14

#21		
#22			(* Alarms.4 := di_rnpp; *)
#23			MOVE		di_rnpp,Alarms.4	{LNXT:10|12|-1}
(*) BOOL
06A658A9  33 C0                         xor eax, eax
06A658AB  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; $$DATA$$+264
06A658B1  84 C0                         test al, al
06A658B3  90 75 11 90 90 90             jne 00000014H@
06A658B9  66 0F BA 35 CC CC CC CC 04    btr word ptr [CCCCCCCCH], 4 ; %M110+14
06A658C2  EB 0C 90 90 90                jmp 0000000EH@
06A658C7  66 0F BA 2D CC CC CC CC 04    bts word ptr [CCCCCCCCH], 4 ; %M110+14

#24		
#25		
#26			(* IF Tank_Level < -32000 *)
#27			LD		Tank_Level	{LNXT:12|-1|-1}
(*) UNDEF
06A658D0  0F BF 05 CC CC CC CC          movsx eax, word ptr [CCCCCCCCH] ; $$DATA$$+24

#28			LT		-32000	{LNXT:12|-1|-1}
(*) INT
06A658D7  3D 00 83 FF FF                cmp eax, -32000
06A658DC  0F 9C C0                      setl al
06A658DF  25 FF 00 00 00                and eax, 0FFh

#29			JMPCN	$label0	{LNXT:12|13|3}
(-) BOOL
06A658E4  84 C0                         test al, al
06A658E6  90 74 27 90 90 90             je 06A65910H

#30		
#31			(* THEN *)
#32		
#33				(* Alarms.11 := True; *)
#34				MOVE		True,Alarms.11	{LNXT:13|3|-1}
(*) BOOL
06A658EC  B8 01 00 00 00                mov eax, 01H
06A658F1  84 C0                         test al, al
06A658F3  90 75 11 90 90 90             jne 00000014H@
06A658F9  66 0F BA 35 CC CC CC CC 0B    btr word ptr [CCCCCCCCH], 11 ; %M110+14
06A65902  EB 0C 90 90 90                jmp 0000000EH@
06A65907  66 0F BA 2D CC CC CC CC 0B    bts word ptr [CCCCCCCCH], 11 ; %M110+14

END_PROGRAM
**************************************************
	List program: MotoHour
**************************************************

PROGRAM MotoHour

        VAR
MotoHour_Mode_1 : REAL := 0.0;	{ DE:"Час, напрацювання мс насос А" }
MotoHour_Mode_2 : REAL := 0.0;	{ DE:"Час, напрацювання мс насос В" }
MotoHour_Mode_3 : REAL := 0.0;	{ DE:"Час, напрацювання мс насос С" }
	END_VAR

END_PROGRAM

#0		{SRC:MotoHour}
#1		(*$WAITSWITCH$*)
#2		
#3		
#4			(* IF Motor_A *)
#5			LD		Motor_A	{LNXT:3|-1|-1}
(*) UNDEF
06A65910  33 C0                         xor eax, eax
06A65912  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#6			JMPCN	$label0	{LNXT:3|4|6}
(-) BOOL
06A65918  84 C0                         test al, al
06A6591A  90 74 1D 90 90 90             je 06A6593AH

#7		
#8			(* THEN *)
#9		
#10				(* MotoHour_Mode_1 := MotoHour_Mode_1 + 1; *)
#11				LD		MotoHour_Mode_1	{LNXT:4|6|-1}
(*) UNDEF
06A65920  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+252

#12				ADD		1	{LNXT:4|6|-1}
(*) REAL
06A65926  68 01 00 00 00                push 1
06A6592B  DA 04 24                      fiadd dword ptr [esp]
06A6592E  81 C4 04 00 00 00             add esp, 4

#13				ST		MotoHour_Mode_1	{LNXT:4|6|-1}
(*) REAL
06A65934  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; $$DATA$$+252

#14		
#15		$label0:
#16			(* END_IF *)
#17		
#18		
#19			(* IF Motor_A *)
#20			LD		Motor_A	{LNXT:6|-1|-1}
(*) UNDEF
06A6593A  DD C0                         ffree
06A6593C  D9 F7                         fincstp
06A6593E  33 C0                         xor eax, eax
06A65940  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+0

#21			NOT	{LNXT:6|-1|-1}
(*) BOOL
06A65946  84 C0                         test al, al
06A65948  0F 94 C0                      sete al

#22			JMPCN	$label1	{LNXT:6|7|11}
(-) BOOL
06A6594B  84 C0                         test al, al
06A6594D  90 74 2D 90 90 90             je 06A6597DH

#23		
#24			(* THEN *)
#25		
#26				(* MotoHour_Mode_1 := MotoHour_Mode_1; *)
#27				MOVE		MotoHour_Mode_1,MotoHour_Mode_1	{LNXT:7|8|-1}
(*) BOOL
06A65953  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+252
06A65959  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; $$DATA$$+252

#28		
#29				(* MotoHour_1 := MotoHour_Mode_1 / 3600; *)
#30				LD		MotoHour_Mode_1	{LNXT:8|11|-1}
(*) UNDEF
06A6595F  DD C0                         ffree
06A65961  D9 F7                         fincstp
06A65963  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+252

#31				DIV		3600	{LNXT:8|11|-1}
(*) REAL
06A65969  68 10 0E 00 00                push 3600
06A6596E  DA 34 24                      fidiv [esp]
06A65971  81 C4 04 00 00 00             add esp, 4

#32				ST		MotoHour_1	{LNXT:8|11|-1}
(*) REAL
06A65977  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; %M110+20

#33		
#34		$label1:
#35			(* END_IF *)
#36		
#37		
#38			(* IF Motor_B *)
#39			LD		Motor_B	{LNXT:11|-1|-1}
(*) UNDEF
06A6597D  DD C0                         ffree
06A6597F  D9 F7                         fincstp
06A65981  33 C0                         xor eax, eax
06A65983  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#40			JMPCN	$label2	{LNXT:11|12|14}
(-) BOOL
06A65989  84 C0                         test al, al
06A6598B  90 74 1D 90 90 90             je 06A659ABH

#41		
#42			(* THEN *)
#43		
#44				(* MotoHour_Mode_2 := MotoHour_Mode_2 + 1; *)
#45				LD		MotoHour_Mode_2	{LNXT:12|14|-1}
(*) UNDEF
06A65991  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+256

#46				ADD		1	{LNXT:12|14|-1}
(*) REAL
06A65997  68 01 00 00 00                push 1
06A6599C  DA 04 24                      fiadd dword ptr [esp]
06A6599F  81 C4 04 00 00 00             add esp, 4

#47				ST		MotoHour_Mode_2	{LNXT:12|14|-1}
(*) REAL
06A659A5  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; $$DATA$$+256

#48		
#49		$label2:
#50			(* END_IF *)
#51		
#52		
#53			(* IF Motor_B *)
#54			LD		Motor_B	{LNXT:14|-1|-1}
(*) UNDEF
06A659AB  DD C0                         ffree
06A659AD  D9 F7                         fincstp
06A659AF  33 C0                         xor eax, eax
06A659B1  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+1

#55			NOT	{LNXT:14|-1|-1}
(*) BOOL
06A659B7  84 C0                         test al, al
06A659B9  0F 94 C0                      sete al

#56			JMPCN	$label3	{LNXT:14|15|19}
(-) BOOL
06A659BC  84 C0                         test al, al
06A659BE  90 74 2D 90 90 90             je 06A659EEH

#57		
#58			(* THEN *)
#59		
#60				(* MotoHour_Mode_2 := MotoHour_Mode_2; *)
#61				MOVE		MotoHour_Mode_2,MotoHour_Mode_2	{LNXT:15|16|-1}
(*) BOOL
06A659C4  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+256
06A659CA  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; $$DATA$$+256

#62		
#63				(* MotoHour_2 := MotoHour_Mode_2 / 3600; *)
#64				LD		MotoHour_Mode_2	{LNXT:16|19|-1}
(*) UNDEF
06A659D0  DD C0                         ffree
06A659D2  D9 F7                         fincstp
06A659D4  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+256

#65				DIV		3600	{LNXT:16|19|-1}
(*) REAL
06A659DA  68 10 0E 00 00                push 3600
06A659DF  DA 34 24                      fidiv [esp]
06A659E2  81 C4 04 00 00 00             add esp, 4

#66				ST		MotoHour_2	{LNXT:16|19|-1}
(*) REAL
06A659E8  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; %M110+24

#67		
#68		$label3:
#69			(* END_IF *)
#70		
#71		
#72			(* IF Motor_C *)
#73			LD		Motor_C	{LNXT:19|-1|-1}
(*) UNDEF
06A659EE  DD C0                         ffree
06A659F0  D9 F7                         fincstp
06A659F2  33 C0                         xor eax, eax
06A659F4  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#74			JMPCN	$label4	{LNXT:19|20|22}
(-) BOOL
06A659FA  84 C0                         test al, al
06A659FC  90 74 1D 90 90 90             je 06A65A1CH

#75		
#76			(* THEN *)
#77		
#78				(* MotoHour_Mode_2 := MotoHour_Mode_2 + 1; *)
#79				LD		MotoHour_Mode_2	{LNXT:20|22|-1}
(*) UNDEF
06A65A02  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+256

#80				ADD		1	{LNXT:20|22|-1}
(*) REAL
06A65A08  68 01 00 00 00                push 1
06A65A0D  DA 04 24                      fiadd dword ptr [esp]
06A65A10  81 C4 04 00 00 00             add esp, 4

#81				ST		MotoHour_Mode_2	{LNXT:20|22|-1}
(*) REAL
06A65A16  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; $$DATA$$+256

#82		
#83		$label4:
#84			(* END_IF *)
#85		
#86		
#87			(* IF Motor_C *)
#88			LD		Motor_C	{LNXT:22|-1|-1}
(*) UNDEF
06A65A1C  DD C0                         ffree
06A65A1E  D9 F7                         fincstp
06A65A20  33 C0                         xor eax, eax
06A65A22  8A 05 CC CC CC CC             mov al, [CCCCCCCCH] ; %Q1+2

#89			NOT	{LNXT:22|-1|-1}
(*) BOOL
06A65A28  84 C0                         test al, al
06A65A2A  0F 94 C0                      sete al

#90			JMPCN	$label5	{LNXT:22|23|3}
(-) BOOL
06A65A2D  84 C0                         test al, al
06A65A2F  90 74 31 90 90 90             je 06A65A63H

#91		
#92			(* THEN *)
#93		
#94				(* MotoHour_Mode_2 := MotoHour_Mode_2; *)
#95				MOVE		MotoHour_Mode_2,MotoHour_Mode_2	{LNXT:23|24|-1}
(*) BOOL
06A65A35  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+256
06A65A3B  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; $$DATA$$+256

#96		
#97				(* MotoHour_2 := MotoHour_Mode_2 / 3600; *)
#98				LD		MotoHour_Mode_2	{LNXT:24|3|-1}
(*) UNDEF
06A65A41  DD C0                         ffree
06A65A43  D9 F7                         fincstp
06A65A45  D9 05 CC CC CC CC             fld dword ptr [CCCCCCCCH] ; $$DATA$$+256

#99				DIV		3600	{LNXT:24|3|-1}
(*) REAL
06A65A4B  68 10 0E 00 00                push 3600
06A65A50  DA 34 24                      fidiv [esp]
06A65A53  81 C4 04 00 00 00             add esp, 4

#100				ST		MotoHour_2	{LNXT:24|3|-1}
(*) REAL
06A65A59  D9 15 CC CC CC CC             fst dword ptr [CCCCCCCCH] ; %M110+24
06A65A5F  DD C0                         ffree
06A65A61  D9 F7                         fincstp

06A65A63  61                            popad
06A65A64  5D                            pop ebp

06A65A65  C3                            ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
06A65A66  55                            push ebp
06A65A67  8B EC                         mov ebp, esp

06A65A69  66 8B 0D CC CC CC CC          mov cx, [CCCCCCCCH] ; %I1+0
06A65A70  66 89 0D CC CC CC CC          mov [CCCCCCCCH], cx ; $$DATA$$+24

06A65A77  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+0
06A65A7D  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+30

06A65A83  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+1
06A65A89  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+32

06A65A8F  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+2
06A65A95  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+34

06A65A9B  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+3
06A65AA1  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+133

06A65AA7  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+4
06A65AAD  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+226

06A65AB3  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+5
06A65AB9  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+227

06A65ABF  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+6
06A65AC5  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+260

06A65ACB  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+7
06A65AD1  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+261

06A65AD7  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+8
06A65ADD  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+262

06A65AE3  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+9
06A65AE9  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+263

06A65AEF  8A 0D CC CC CC CC             mov cl, [CCCCCCCCH] ; %I0+10
06A65AF5  88 0D CC CC CC CC             mov [CCCCCCCCH], cl ; $$DATA$$+264

06A65AFB  8B E5                         mov esp, ebp
06A65AFD  5D                            pop ebp

06A65AFE  C3                            ret


*** OUTPUT:
06A65AFF  55                            push ebp
06A65B00  8B EC                         mov ebp, esp

06A65B02  8B E5                         mov esp, ebp
06A65B04  5D                            pop ebp

06A65B05  C3                            ret



**************************************************
	Task Timed init code
**************************************************

06A65B06  55                            push ebp
06A65B07  8B EC                         mov ebp, esp

Var init: V::LVL.PRIORITYMOTOR = 1
06A65B09  66 C7 05 CC CC CC CC 01 00    mov word ptr [CCCCCCCCH], 0001H ; $$DATA$$+20

Var init: V::LVL.MAX_LEVEL_1 = 80
06A65B12  66 C7 05 CC CC CC CC 50 00    mov word ptr [CCCCCCCCH], 0050H ; $$DATA$$+26

Var init: V::LVL.ROTATIONNUMBER = 1
06A65B1B  66 C7 05 CC CC CC CC 01 00    mov word ptr [CCCCCCCCH], 0001H ; $$DATA$$+28

Var init: V::LVL.CURRENTPUMP = 1
06A65B24  66 C7 05 CC CC CC CC 01 00    mov word ptr [CCCCCCCCH], 0001H ; $$DATA$$+36

Var init: V::LVL.MAX_LEVEL_2 = 120
06A65B2D  66 C7 05 CC CC CC CC 78 00    mov word ptr [CCCCCCCCH], 0078H ; $$DATA$$+62

Var init: V::LVL.MAX_LEVEL_3 = 150
06A65B36  66 C7 05 CC CC CC CC 96 00    mov word ptr [CCCCCCCCH], 0096H ; $$DATA$$+178

Var init: V::LVL.MIN_LEVEL = 30
06A65B3F  66 C7 05 CC CC CC CC 1E 00    mov word ptr [CCCCCCCCH], 001EH ; $$DATA$$+180

06A65B48  8B E5                         mov esp, ebp
06A65B4A  5D                            pop ebp

06A65B4B  C3                            ret



**************************************************
	Global init code
**************************************************

06A65B50  55                            push ebp
06A65B51  8B EC                         mov ebp, esp

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$BACKGROUND = [?main.$$POUCB$$, 0]
06A65B53  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+300
06A65B58  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+268

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$SERV = [?InitParDB.$$POUCB$$, 0]
06A65B5E  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+306
06A65B63  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+276

Var init: V:EMBEDDEDELEMENTS:$$POUCBARRAY$$TIMED = [?LVL.$$POUCB$$, ?Register.$$POUCB$$, ?MotoHour.$$POUCB$$, 0]
06A65B69  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+312
06A65B6E  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+284
06A65B74  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+318
06A65B79  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+288
06A65B7F  B9 CC CC CC CC                mov ecx, CCCCCCCCH ; $$DATA$$+324
06A65B84  89 0D CC CC CC CC             mov [CCCCCCCCH], ecx ; $$DATA$$+292

06A65B8A  8B E5                         mov esp, ebp
06A65B8C  5D                            pop ebp

06A65B8D  C3                            ret



**************************************************
	Global RETAIN init code
**************************************************

06A65B8E  55                            push ebp
06A65B8F  8B EC                         mov ebp, esp

06A65B91  8B E5                         mov esp, ebp
06A65B93  5D                            pop ebp

06A65B94  C3                            ret



**************************************************
	Task $$VirtualTables init code
**************************************************

06A65B95  55                            push ebp
06A65B96  8B EC                         mov ebp, esp

06A65B98  8B E5                         mov esp, ebp
06A65B9A  5D                            pop ebp

06A65B9B  C3                            ret



********************************************
MEMORY MAP
********************************************

Code area type:          		       main code
Start code area:          		0000000006A60000h
End code area:            		0000000006A666B8h
Code size:                		000066B8h

Start local data area:    		00000000068E0000h
End local data area:      		00000000068E014Ah
Local data size:          		0000014Ah

Start retentive data area:		0000000000000000h
End retentive data area:  		0000000000000000h
Retentive data size:      		00000000h

Start bit data area:      		0000000000000000h
End bit data area:        		0000000000000000h
Bit data size:            		00000000h



********************************************
CODE ID:                                6D0CDF67
DEBUG MEMO ID:                          000034F7
FULL MEMO ID:                           0000C16D
RELOCATION ADDR:                        0000000006A60000
********************************************
